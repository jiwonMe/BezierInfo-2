# 원호로 베지에 곡선 근사하기

이전 섹션과 정반대의 작업을 살펴봅시다. 베지에 곡선을 사용하여 원호를 근사하는 대신, 원호를 사용하여 베지에 곡선을 근사해봅시다.

원 근사 섹션에서 이것이 완벽한 동등물을 산출하지 않는다는 것을 이미 봤지만, 때로는 제조 기계 또는 선과 원은 이해하지만 다른 것은 별로 이해하지 못하는 간단한 벡터 언어로 작업할 때와 같이 원호가 필요합니다.

접근 방식은 상당히 간단합니다. 곡선의 시작점을 선택하고 곡선을 따라 더 멀리 있는 두 점을 선택합니다. 이 세 점을 통과하는 원을 결정하고 근사하려는 곡선 부분에 맞는지 확인합니다. 괜찮은 맞춤? 점을 더 멀리 간격을 띄워봅니다. 나쁜 맞춤? 점을 더 가깝게 간격을 띄워봅니다. "좋은 근사/나쁜 근사" 경계를 찾을 때까지 계속하고, "좋은" 호를 기록한 다음 시작점을 이전에 찾은 끝점과 겹치도록 이동합니다. 전체 곡선을 다룰 때까지 헹구고 반복합니다.

[세 점으로 곡선 만들기](#pointcurves) 섹션에서 세 점을 통과하는 원을 맞추는 방법을 이미 봤고, 이 점들을 통과하는 호를 찾는 것은 간단합니다. 세 점 중 하나를 시작점으로 선택하고 다른 하나를 끝점으로 선택하면 호는 필연적으로 시작점에서 끝점까지 나머지 점을 거쳐 가야 합니다.

그렇다면 베지에 곡선을 (일련의) 원호로 어떻게 변환할 수 있을까요?

- `t=0`에서 시작
- 곡선을 따라 더 아래의 두 점을 어떤 값 `m = t + n` 및 `e = t + 2n`에서 선택
- 이 점들이 정의하는 호를 찾기
- 찾은 호가 곡선에 얼마나 가까운지 결정:
  - 두 개의 추가 점 `e1 = t + n/2` 및 `e2 = t + n + n/2`를 선택합니다.
  - 호가 선택한 곡선 구간의 좋은 근사라면 이 점들은 원 `위에` 놓여야 하므로 원의 중심까지의 거리가 다른 세 점에서 중심까지의 거리와 같아야 합니다.
  - 각 점에 대해 원의 반경과 원의 중심에서 곡선 위의 점까지의 `실제` 거리 사이의 (절대) 오차를 결정합니다.
  - 이 오차가 너무 크면 호가 나쁘다고 간주하고 더 작은 구간을 시도합니다.

이것의 결과는 다음 그래픽에 표시됩니다. 보장된 실패부터 시작합니다: s=0, e=1. 전체 곡선입니다. 중간점은 단순히 `t=0.5`에 있고, 그런 다음 [이진 검색](https://en.wikipedia.org/wiki/Binary_search_algorithm)을 수행하기 시작합니다.

1. `low=0`, `mid=0.5`, `high=1`로 시작
2. 실패할 것이므로 구간을 절반으로 줄여서 다시 시도: `{0, 0.25, 0.5}`
  - 그 호가 좋으면 절반 거리만큼 다시 올라갑니다: `{0, 0.375, 0.75}`.
  - 하지만 호가 여전히 나쁘면 절반 거리만큼 _아래로_ 이동합니다: `{0, 0.125, 0.25}`.
3. 첫 번째 호는 좋고 두 번째 호는 나쁜, 연속된 두 호를 찾을 때까지 이것을 반복합니다. 그 쌍을 찾으면 좋은 근사와 나쁜 근사 사이의 경계를 찾은 것이고, 좋은 호를 선택합니다.

다음 그래픽은 이 접근 방식의 결과를 보여주며, 기본 오차 임계값은 0.5입니다. 즉, 호가 두 검증 점 모두에 걸쳐 <em>합쳐서</em> 반 픽셀 떨어져 있으면 호를 나쁘다고 취급합니다. 이것은 매우 간단한 오차 정책이지만 이미 정말 잘 작동합니다. 그래픽은 여전히 인터랙티브하며 상하 방향키를 사용하여 오차 임계값을 늘리거나 줄여서 더 작거나 큰 오차 임계값의 효과를 볼 수 있습니다.

<graphics-element title="베지에 곡선의 첫 번째 호 근사" src="./arc.js">
  <input type="range" min="0.1" max="5" step="0.1" value="0.5" class="slide-control">
</graphics-element>

이것이 제자리에 있으면 이제 남은 것은 찾은 호의 끝점을 새로운 호의 시작점으로 취급하고 곡선을 따라 더 아래의 점을 사용하여 절차를 "재시작"하는 것입니다. 찾은 끝점이 <em>t=1</em>일 때까지 이것을 계속 시도하며, 그 시점에서 완료됩니다. 다시 말하지만, 다음 그래픽은 상하 방향키 입력을 허용하여 오차 임계값을 늘리거나 줄일 수 있으므로 다른 임계값을 선택하면 곡선을 합리적으로 근사하는 데 필요한 호의 수가 어떻게 변하는지 볼 수 있습니다.

<graphics-element title="베지에 곡선의 호 근사" src="./arcs.js">
  <input type="range" min="0.1" max="5" step="0.1" value="0.5" class="slide-control">
</graphics-element>

그럼... 이것이 무엇에 좋을까요? 분명히 곡선은 할 수 없지만 선과 원은 할 수 있는 기술로 작업하는 경우 답은 꽤 간단하지만, 다른 것은? 이 기술이 필요할 수 있는 몇 가지 이유가 있습니다. 원호를 사용하면 좌표가 곡선 "위에" 있는지 정말 쉽게 결정할 수 있습니다(각 원호 중심까지의 거리를 계산하고, 그 중 호 시작과 끝 사이의 각도에서 호 반경에 가까운 것이 있으면, 빙고, 이 점은 "곡선 위에" 있다고 취급할 수 있습니다). 또 다른 이점은 이 근사가 "선형"이라는 것입니다. 거의 사소하게 고정 속도로 호를 따라 이동할 수 있습니다. 근사된 곡선의 호 길이도 사소하게 계산할 수 있습니다(곡선 평탄화와 비슷합니다). 명심해야 할 유일한 것은 이것이 손실 동등성이라는 것입니다. 근사를 기반으로 계산하는 것은 약간의 값만큼 "벗어나"도록 보장되며, 필요한 정밀도에 따라 호 근사는 엄청나게 유용하거나 완전히 쓸모없을 것입니다. 애플리케이션에 따라 결정하는 것은 여러분에게 달려 있습니다!
