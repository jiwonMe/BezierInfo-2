# 원과의 교차점

몇 섹션 전의 선/선, 선/곡선, 곡선/곡선 교차 주제보다 훨씬 나중에 이 주제를 다루는 것이 이상해 보일 수 있지만, 원/곡선 교차를 다룰 수 없는 이유는 곡선에 점을 투영하는 섹션에서 사용하는 종류의 조회 테이블(LUT) 워킹을 다루기 전까지는 원/곡선 교차를 실제로 논의할 수 없기 때문입니다. 왜 그런지 보기 위해 미적분을 사용하여 곡선과 원 사이의 교차점을 찾으려면 무엇을 해야 하는지 살펴봅시다.

먼저 이 경우 "교차점 찾기"는 중심점 `c = (x,y)`와 반경 `r`로 정의된 원이 주어졌을 때, 원의 중심점까지의 거리가 원 반경과 같은 베지에 곡선의 모든 점을 찾고 싶다는 것을 의미하며, 정의에 따라 그 점들이 원 위에 있으므로 교차점으로 간주된다는 것을 관찰합니다. 수학적으로 우리는 다음을 풀려고 합니다.

\[
  \textit{dist}(B(t), c) = r
\]

충분히 간단해 보입니다. 안타깝게도 `dist` 함수를 전개하면 상황이 훨씬 더 문제가 됩니다.

\[
  \begin{aligned}
    r &= \textit{dist}(B(t), c) \\
    &= \sqrt{ \left ( B_x{t} - c_x \right )^2 + \left ( B_y{t} - c_y \right )^2} \\
    &= \sqrt{ \left (
      x_1 (1-t)^3 + 3 x_2 (1-t)^2 t + 2 x_3 (1-t) t^2 + x_4 t^3 - c_x
    \right )^2
    +
    \left (
      y_1 (1-t)^3 + 3 y_2 (1-t)^2 t + 2 y_3 (1-t) t^2 + y_4 t^3 - c_y
    \right )^2}
  \end{aligned}
\]

이제 문제가 있습니다. 제곱근 안에 6차 다항식이 있기 때문입니다. 따라서 이전에 본 [Abel-Ruffini 정리](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem) 덕분에 "부호에 신경 쓰지 않으므로 양변을 제곱"하는 것만으로는 해결할 수 없습니다... 6차 다항식을 풀 수 없습니다. 따라서 실제로 그 식을 평가해야 합니다. 원의 중심이 (0,0)이 되도록 모든 좌표를 이동하고 모든 좌표를 그에 따라 이동하여 이를 "단순화"할 수 있습니다. 이렇게 하면 c<sub>x</sub> 및 c<sub>y</sub> 항이 사라지지만, 여전히 괴물 같은 함수를 풀어야 합니다.

대신 곡선에 점을 투영할 때 본 것과 같은 종류의 "LUT 워킹"으로 전환하되, 약간의 변형이 있습니다. 투영 점까지 가장 작은 거리를 가진 곡선 위의 점을 찾는 대신, 투영 점(즉, 원의 중심)까지 정확한 거리 `r`을 가진 곡선 위의 점을 찾고 싶습니다. 물론 그러한 점이 하나 이상 있을 수 있으므로 모두 찾을 수 있도록 약간 더 많은 코드가 있지만, 관련 단계를 살펴봅시다.

```
p = 원의 중심점
r = 원의 반경
d = 처음에 매우 큰 값
i = 0
for (coordinate, index) in LUT:
  q = abs(distance(coordinate, p) - r)
  if q < d:
    d = q
    i = index
```

이것은 이전 섹션의 코드와 _매우_ 유사하며, 원 반경에 대한 추가 입력 `r`과 "이 좌표에 대한 거리"의 사소한 변경이 있습니다. 단순히 `distance(coordinate, p)`가 아니라 그 거리와 원 반경 사이의 차이를 알고 싶습니다. 결국 그 차이가 0이면 좌표에서 원 중심까지의 거리가 정확히 반경이므로 좌표는 곡선과 원 모두에 있습니다.

지금까지는 좋습니다.

그러나 하나만이 아니라 _모든_ 점을 찾아야 하므로 이를 위해 약간 더 많은 코드가 필요합니다.

```
p = 원의 중심점
r = 원의 반경
d = 처음에 매우 큰 값
start = 0
values = []
do:
    i = findClosest(start, p, r, LUT)
    if i < start, or i>0 but the same as start: stop
    values.add(i);
    start = i + 2;
```

이 코드를 실행한 후 `values`는 거리 `r`에 가장 가까운 모든 LUT 좌표의 목록이 됩니다. 이 값을 사용하여 점 투영에 사용한 것과 같은 종류의 정제 조회를 실행할 수 있으며(이제 가장 작은 거리를 확인하는 것이 _아니라_ "`r`에 가장 가까운 거리"를 확인한다는 주의 사항이 있음), 모든 교차점을 갖게 됩니다. 물론 `findClosest`가 무엇을 하는지 설명해야 합니다. 전역 최소값을 찾는 대신 이제 _지역_ 최소값을 찾는 데 관심이 있으므로 단일 점을 확인하고 거리 값을 보는 대신 _세_ 점("현재", "이전" 및 "이전의 이전")을 확인한 다음 지역 최소값을 형성하는지 확인합니다.

```
findClosest(start, p, r, LUT):
    minimizedDistance = 매우 큰 숫자
    pd2 = LUT[start-2], 존재하는 경우. 그렇지 않으면 minimizedDistance 사용
    pd1 = LUT[start-1], 존재하는 경우. 그렇지 않으면 minimizedDistance 사용
    slice = LUT.subset(start, LUT.length)
    epsilon = LUT에서 가장 큰 점간 거리
    i = -1;

    for (coordinate, index) in slice:
        q = abs(dist(coordinate, p) - r);
        if pd1 less than all three values epsilon, pd2, and q:
            i = index - 1
            break

        minimizedDistance = min(q, minimizedDistance)
        pd2 = pd1
        pd1 = q

  return start + i
```

말로 하면: `start` 인덱스, 원 중심 및 반경, LUT가 주어졌을 때 "곡선에서 원 중심까지의 거리"와 원의 반경 사이의 차이에 대한 지역 최소값을 (`start` 인덱스에 가장 가까운) 어디에서 찾을 수 있는지 확인합니다. 세 값(인덱스 `index-2`, `index-1`, `index`와 연관된)을 보면서 추적하고, 세 값이 중간 값(`pd1`)이 양쪽 값보다 작음을 보여주면 지역 최소값을 찾았다는 것을 알게 됩니다. 그럴 때 `start`에 대한 "최선의 추측"을 `index-1`로 설정할 수 있습니다. 물론 이제 일부 `start` 값에 대해 상대적으로 값을 확인하고 있으므로 다른 후보 값을 전혀 찾지 못할 수도 있으며, 이 경우 `start - 1`을 반환하여 간단한 "결과가 `start`보다 작은가?"로 더 이상 찾을 교차점이 없다는 것을 결정할 수 있습니다.

마지막으로, 점 투영에는 필요하지 않지만 후보 LUT 인덱스에서 이진 정제 함수를 실행할 때 수행해야 하는 단계가 하나 더 있습니다. 지금까지 "원의 반경에 가장 가까운" 거리를 사용하여 테스트만 했는데, 실제로는 충분하지 않기 때문입니다... 원의 반경인 거리가 _필요_합니다. 따라서 이러한 각 인덱스에 대해 정제를 실행한 후 원 반경이 아닌 최종 값을 폐기해야 합니다. 그리고 부동 소수점 숫자로 작업하고 있기 때문에 이것이 실제로 의미하는 것은 픽셀 이상 "벗어난" 값을 폐기해야 한다는 것입니다. 또는 정말 멋지게 하고 싶다면 "작은 `epsilon` 값"입니다.

이 모든 것을 기반으로 다음 그래픽은 표준 3차 곡선(물론 좌표를 이동할 수 있음)과 그래픽 중심을 중심으로 제어 가능한 반경을 가진 원에 대해 위에서 설명한 코드 접근 방식을 사용하여 이를 보여줍니다.

<graphics-element title="원 교차점" src="./circle.js">
  <input type="range" min="1" max="150" step="1" value="70" class="slide-control">
</graphics-element>

물론 전체 세부 정보는 "소스 보기" 링크를 클릭하세요.
