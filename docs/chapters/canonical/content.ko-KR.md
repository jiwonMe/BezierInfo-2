# 표준 형식 (3차 곡선용)

2차 곡선은 분석하기에 비교적 간단한 곡선이지만, 3차 곡선에 대해서는 같은 말을 할 수 없습니다. 곡률이 하나 이상의 제어점에 의해 제어되므로 루프, 첨점, 이상한 공선 특징과 같은 모든 종류의 특징을 보이며, 곡률이 최대 세 번 방향을 변경할 수 있으므로 최대 두 개의 변곡점을 가질 수 있습니다. 이제 우리가 다루는 곡선 유형을 아는 것은 일부 알고리즘을 일반 솔버로 구현해야 하는 경우보다 더 효율적으로 실행할 수 있음을 의미하므로, 많은 작업 없이 곡선 유형을 결정하는 방법이 있을까요?

우연히도 답은 예이며, 우리가 살펴볼 솔루션은 Xerox PARC의 Maureen C. Stone과 University of Washington의 Tony D. deRose가 공동 논문 ["A Geometric Characterization of Parametric Cubic curves"](https://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf)에서 발표했습니다. 1989년에 출판되었으며, 곡선을 "표준" 형식(즉, 모든 곡선을 축소할 수 있는 형식)을 갖는 것으로 정의하여 곡선이 어떤 특징을 가질지 즉시 알 수 있습니다. 그렇다면 어떻게 작동할까요?

작업을 가능하게 하는 첫 번째 관찰은 4개의 점이 있는 3차 곡선이 있다면 이 점에 선형 변환을 적용하여 세 점이 (0,0), (0,1), (1,1)에 끝나도록 하고 마지막 점은 "어딘가"에 있도록 할 수 있다는 것입니다. 그 변환을 적용한 후 마지막 점의 위치가 우리가 다루는 곡선의 종류를 알려줄 수 있습니다. 구체적으로 다음 분석을 볼 수 있습니다.

<graphics-element title="표준 곡선 맵" width="400" height="400" src="./canonical.js"></graphics-element>

이것은 상당히 펑키한 이미지이므로 다양한 부분이 무엇을 의미하는지 봅시다...

(0,0), (0,1), (1,1)의 세 고정 점을 볼 수 있습니다. 다양한 영역과 경계는 네 번째 점이 해당 영역이나 경계에 있거나 위에 있는 경우 원래 곡선이 가질 속성을 나타냅니다. 구체적으로 네 번째 점이...

1. ...빨간 영역 내부 어디든, 하지만 그 경계에 있지 않으면 곡선이 자기 교차합니다(루프 산출). *어디서* 자기 교차하는지(*t* 값 측면에서) 알 수 없지만 그렇게 한다는 것은 보장됩니다.

2. ...빨간 영역의 왼쪽(빨간) 가장자리에 있으면 곡선에 첨점이 있습니다. _어디_인지는 다시 모르지만 하나 있다는 것을 압니다. 이 가장자리는 다음 함수로 설명됩니다.

  \[
    y = \frac{-x^2 + 2x + 3}{4}, \{ x \leq 1 \}
  \]

3. ...거의 원형인 오른쪽 아래(분홍) 가장자리에 있으면 곡선의 끝점이 곡선과 접촉하여 루프를 형성합니다. 이 가장자리는 다음 함수로 설명됩니다.

  \[
    y = \frac{\sqrt{3(4x - x^2)} - x}{2}, \{ 0 \leq x \leq 1 \}
  \]

4. ...위쪽(파란) 가장자리에 있으면 곡선의 시작점이 곡선과 접촉하여 루프를 형성합니다. 이 가장자리는 다음 함수로 설명됩니다.

  \[
    y = \frac{-x^2 + 3x}{3}, \{ x \leq 0 \}
  \]

5. ...아래쪽(녹색) 영역 내부, `y=1`을 지나면 곡선에 단일 변곡이 있습니다(오목/볼록을 한 번 전환).

6. ...왼쪽과 아래쪽 경계 사이(첨점 선 아래이지만 단일 변곡 선 위)에 있으면 곡선에 두 개의 변곡이 있습니다(오목에서 볼록으로 전환한 다음 다시 돌아오거나, 볼록에서 오목으로 전환한 다음 다시 돌아옴).

7. ...자기 교차 영역의 오른쪽 어디든 있으면 곡선에 변곡이 없습니다. 단순한 아치일 뿐입니다.

물론 이 맵은 상당히 작지만 영역은 잘 정의된 경계와 함께 무한대로 확장됩니다.

<div class="note">

### 잠깐, 그 선들은 어디서 왔나요?

이 섹션 맨 위에 언급된 논문을 반복하지 않고, 루프 경계는 곡선을 표준 형식으로 다시 쓴 다음 어떤 가능한 곡선 속성에 대해 어떤 제약 조건이 유지되어야 하는지에 대한 공식을 푸는 것에서 나옵니다. 논문에서 이러한 함수는 첨점을 찾을 곳이나 t=0 또는 t=1임을 알고 있는 루프에 대한 공식을 산출하지만, 이러한 함수는 전체 3차 식에 대해 도출되므로 t=-∞에서 t=∞까지 적용됩니다... 베지에 곡선의 경우 "잘린 간격" t=0에서 t=1만 신경 쓰므로 무한 간격에 걸쳐 곡선을 볼 때 적용되는 일부 속성은 베지에 곡선 간격에는 단순히 적용되지 않습니다.

일반 3차 곡선에 대해 곡선이 "변곡을 가짐"에서 "루프를 가짐"으로 전환하는 곳을 나타내는 루프 영역의 오른쪽 경계는 실제로 x=1에서 미러링되지만, 베지에 곡선의 경우 이 오른쪽 절반은 적용되지 않으므로 주의를 기울일 필요가 없습니다. 마찬가지로 t=0 및 t=1 루프의 경계도 멋진 깨끗한 곡선이지만 t=0에서 t=1까지의 간격에 걸쳐 일반 곡선이 수행하는 것만 볼 때 "잘립니다".

전체 세부 정보는 논문으로 가서 섹션 3과 4를 읽어보세요. 고등학교 예비 미적분을 여전히 기억한다면 아마도 이 논문을 따라갈 수 있지만, 모든 부분이 "딸깍"하기 전에 몇 번 읽어야 할 수도 있습니다.

</div>

그렇다면 이제 질문은: 세 개의 고정 점과 하나의 "자유" 점으로 이 표준 형식에 맞도록 곡선을 어떻게 조작할까요? 선형 대수학 등장. 걱정하지 마세요, 모든 수학을 제가 해드리고 곡선에 미치는 영향도 보여드리겠습니다만, 기본적으로 미적분이 아니라 선형 대수학을 사용할 것입니다. "훨씬 더 쉽기" 때문입니다. 때로는 동등한 기하학적 솔루션이 엄청나게 명백할 때 미적분 접근 방식이 매우 작업하기 어렵습니다.

접근 방식은 모든 공선 점이 아닌 곡선으로 시작한 다음(따라서 점이 모두 직선에 떨어지지 않도록 해야 함) 아마도 들어본 세 가지 그래픽 연산을 적용합니다. 이동(모든 점을 일부 고정 x 및 y 거리만큼 이동), 확대/축소(모든 점을 일부 x 및 y 확대/축소 인수로 곱하기), 전단(직사각형을 평행사변형으로 바꾸는 연산).

1단계: 곡선이 (0,0)에서 시작하도록 모든 곡선을 -p1.x 및 -p1.y만큼 이동합니다. 여기서 흥미로운 트릭을 사용할 것인데, 2D 좌표가 3D인 척하고 *z* 좌표가 항상 1이라고 가정합니다. 이것은 2D 변환의 한계를 극복하기 위한 그래픽의 오래된 트릭입니다. 이것이 없으면 (x,y) 좌표를 (ax + by, cx + dy) 형태의 새 좌표로만 바꿀 수 있으며, 이는 (x + a, y + b) 같은 것으로 끝나야 하므로 이동을 할 수 없다는 것을 의미합니다. 항상 1인 가짜 *z* 좌표를 추가하면 갑자기 임의의 값을 추가할 수 있습니다. 예를 들어:

\[
\left [ \begin{array}{ccc}
    1 & 0 & a \\
    0 & 1 & b \\
    0 & 0 & 1
  \end{array} \right ]
\cdot
\left [
  \begin{matrix}
    x \\
    y \\
    z=1
  \end{matrix}
\right ]
=
\left [
  \begin{matrix}
    1 \cdot x + 0 \cdot y + a \cdot z \\
    0 \cdot x + 1 \cdot y + b \cdot z \\
    0 \cdot x + 0 \cdot y + 1 \cdot z
  \end{matrix}
\right ]
=
\left [
  \begin{matrix}
    x + a \cdot 1 \\
    y + b \cdot 1 \\
    1 \cdot z
  \end{matrix}
\right ]
=
\left [
  \begin{matrix}
    x + a \\
    y + b \\
    z=1
  \end{matrix}
\right ]
\]

좋습니다! *z*는 1로 유지되므로 완전히 무시할 수 있지만 x 및 y 좌표에 일반 값을 추가했습니다. 따라서 p1.x와 p1.y를 빼려면 다음을 사용합니다.

\[
T_1 =
\left [ \begin{array}{ccc}
    1 & 0 & -{P_1}_x \\
    0 & 1 & -{P_1}_y \\
    0 & 0 & 1
  \end{array} \right ]
\cdot
\left [
  \begin{matrix}
    x \\
    y \\
    1
  \end{matrix}
\right ]
=
\left [
  \begin{matrix}
    1 \cdot x + 0 \cdot y - {P_1}_x \cdot 1 \\
    0 \cdot x + 1 \cdot y - {P_1}_y \cdot 1 \\
    0 \cdot x + 0 \cdot y + 1 \cdot 1
  \end{matrix}
\right ]
=
\left [
  \begin{matrix}
    x - {P_1}_x \\
    y - {P_1}_y \\
    1
  \end{matrix}
\right ]
\]

이 변환을 통해 모든 좌표를 실행하면 새 좌표 집합이 생기며, 이를 **U**라고 부르겠습니다. 여기서 첫 번째 좌표는 (0,0)에 놓이고 나머지는 여전히 다소 자유롭습니다. 다음 작업은 점 2가 *x=0* 선에 놓이도록 하는 것이므로, 실행할 때 현재 가진 *x*에서 *x*를 빼는 변환 행렬을 원합니다. 이것을 [전단](https://en.wikipedia.org/wiki/Shear_matrix)이라고 하며, 일반적인 x 전단 행렬과 그 변환은 다음과 같습니다.

\[
\left [
  \begin{matrix}
    1 & S & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1
  \end{matrix}
\right ]
\cdot
\left [
  \begin{matrix}
    x \\
    y \\
    1
  \end{matrix}
\right ]
=
\left [
  \begin{matrix}
    x + S \cdot y \\
    y \\
    1
  \end{matrix}
\right ]
\]

따라서 *y*와 곱했을 때 *-x*를 산출하는 전단 값을 원하므로 x 좌표가 0이 됩니다. 그 값은 단순히 *-x/y*입니다. *-x/y * y = -x*이기 때문입니다. 끝:

\[
T_2 =
\left [
  \begin{matrix}
    1 & -\frac{ {U_2}_x }{ {U_2}_y } & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 1
  \end{matrix}
\right ]
\]

이제 모든 점에서 이것을 실행하면 새 좌표 집합이 생성되며, 이를 **V**라고 부르겠습니다. 이제 점 1은 (0,0)에, 점 2는 (0, 어떤-값)에 있으며, (0,1)에 있기를 원했으므로 (0,1)에 끝나도록 [약간의 확대/축소](https://en.wikipedia.org/wiki/Scaling_%28geometry%29)를 해야 합니다. 추가로 점 3이 (1,1)에 끝나기를 원하므로 변환을 실행한 후 x 좌표가 1이 되도록 x를 확대/축소할 수도 있습니다. 즉, 1/point3<sub>x</sub>만큼 x 확대/축소하고 point2<sub>y</sub>만큼 y 확대/축소하겠습니다. 이것은 정말 쉽습니다.

\[
T_3 =
\left [
  \begin{matrix}
    \frac{1}{ {V_3}_x } & 0 & 0 \\
    0 & \frac{1}{ {V_2}_y } & 0 \\
    0 & 0 & 1
  \end{matrix}
\right ]
\]

그런 다음 마지막으로 이것은 새 좌표 집합을 생성하며, 이를 W라고 부르겠습니다. 이 중 점 1은 (0,0)에, 점 2는 (0,1)에, 점 3은 (1, ...)에 놓이므로 점 3이 (1,1)에 끝나도록 하는 것만 남았습니다. 하지만 확대/축소할 수 없습니다! 점 2는 이미 올바른 위치에 있고 y 확대/축소하면 (0,1)에서 다시 이동하므로, 유일한 옵션은 이전에 점 2를 x 전단했던 것처럼 점 3을 y 전단하는 것입니다. 이 경우 같은 트릭을 하되, x 전단이 아니라 y 전단이므로 `x/y`가 아니라 `y/x`를 사용합니다. 추가로 실제로 0에 끝나기를 원하지 않으므로(이전에 한 일) 오프셋을 향해 전단해야 하며, 이 경우 1입니다.

\[
T_4 =
\left [
  \begin{matrix}
    1 & 0 & 0 \\
    \frac{1 - {W_3}_y}{ {W_3}_x } & 1 & 0 \\
    0 & 0 & 1
  \end{matrix}
\right ]
\]

그리고 이것은 최종 4개 좌표 집합을 생성합니다. 이 중 점 1~3이 (0,0), (0,1), (1,1)이라는 것을 이미 알고 있으며 마지막 좌표만 "자유"입니다. 사실 네 개의 시작 좌표가 주어지면 결과 "변환 매핑된" 좌표는 다음과 같습니다.

\[
\textit{mapped}_4 = \left (
  \begin{matrix}
  x \\
  y
  \end{matrix}
\right ) = \left (
  \begin{matrix}
    \frac
    {
      -x_1 + x_4 - \frac{(-x_1+x_2)(-y_1+y_4)}{-y_1+y_2}
    }
    {
      -x_1+x_3-\frac{(-x_1+x_2)(-y_1+y_3)}{-y_1+y_2}
    }
\\
    \frac{(-y_1+y_4)}{-y_1+y_2}
    +
    \frac
    {
      \left ( 1 - \frac{-y_1+y_3}{-y_1+y_2} \right )
      \left ( -x_1 + x_4 - \frac{(-x_1+x_2)(-y_1+y_4)}{-y_1+y_2} \right )
    }
    {
      -x_1+x_3-\frac{(-x_1+x_2)(-y_1+y_3)}{-y_1+y_2}
    }
  \end{matrix}
\right )
\]

좋아요, 글쎄요, 그것은 완전히 우스꽝스러워 보이지만: 모든 좌표 값이 초기 이동만큼 오프셋되고 있다는 것을 주목하세요. 또한 그 식에서 _많은_ 항이 반복된다는 것을 주목하세요. 수학이 단일 식으로는 미친 것처럼 보이지만, 이것을 조금 분해하여 계산하기 쉬운 코드로 끝낼 수 있습니다!

먼저 이동 단계를 "전처리" 연산으로 수행하여 항상 값을 빼지 않아도 되도록 합시다. 무엇이 남을까요?

\[
... = \left (
  \begin{matrix}
   x_4 - \frac{x_2 \cdot y_4}{y_2} / x_3-\frac{x_2 \cdot y_3}{y_2}
\\
\\
    \frac{y_4}{y_2}
    +
    \left ( 1 - \frac{y_3}{y_2} \right )
    \cdot
    \left (  x_4 - \frac{x_2 \cdot y_4}{y_2} / x_3-\frac{x_2 \cdot y_3}{y_2} \right )
  \end{matrix}
\right ) = \left (
  \begin{matrix}
   x_{43}
\\
\\
    \frac{y_4}{y_2}
    +
    x_{43}
    \left ( 1 - \frac{y_3}{y_2} \right )
  \end{matrix}
\right ),\textit{ where } x_{43} = \left (
  x_4 - \frac{x_2 \cdot y_4}{y_2} \middle / x_3-\frac{x_2 \cdot y_3}{y_2}
\right )
\]

갑자기 상황이 훨씬 더 간단해 보입니다. 매핑된 x는 계산하기 상당히 간단하고, 매핑된 y가 실제로 매핑된 x 전체를 포함한다는 것을 볼 수 있으므로 평가해야 할 때 그 부분을 이미 사용할 수 있습니다. 사실 이것이 얼마나 간단한지 보기 위해 모든 공통 인수를 빼봅시다.

\[
... = \left (
  \begin{matrix}
   x_{43}
\\
\\
    y_{42}
    +
    x_{43}
    \left ( 1 - y_{32} \right )
  \end{matrix}
\right ), \textit{ where } x_{43} = \left (
  \frac{x_4 - x_2 \cdot y_{42}}{x_3 - x_2 \cdot y_{32}}
\right ), \textit{ } y_{42} = \frac{y_4}{y_2}, \textit{ and } y_{32} = \frac{y_3}{y_2}
\]

코드로 작성하기에 엄청나게 간단하다는 데 동의하실 것 같습니다. 수학을 코딩하는 것은 공식이 처음에 보이게 하는 것보다 쉬운 경향이 있습니다!

<div class="note">

### 그 모든 것을 어떻게 추적하나요?

수학을 하는 것은 고통스러울 수 있으므로, 가능하면 컴퓨터가 저를 위해 작업을 하도록 하는 것을 좋아합니다. 특히 이와 같은 것의 경우 단순히 [Mathematica](https://www.wolfram.com/mathematica/)를 사용합니다. 이 모든 수학을 손으로 추적하는 것은 미친 짓이고, 우리가 컴퓨터를 발명한 것은 문자 그대로 이것을 우리를 위해 하도록 하기 위해서입니다. 프로그램에서 하고 싶은 것을 작성하고 프로그램이 저를 위해 수학을 하도록 할 수 있을 때 펜과 종이를 사용할 이유가 없습니다. 그리고 진짜 수학도, 숫자가 아니라 기호로. 사실 [여기](https://pomax.github.io/gh-weblog-2/downloads/canonical-curve.nb) Mathematica 노트북이 있으니 직접 어떻게 작동하는지 보고 싶다면 확인하세요.

이제 알고 계시겠지만, "하지만 Mathematica는 엄청 비싸요!"라고 생각하실 것이고 그것은 사실입니다. [원래 작성했을 때 $295에서 올라 가정용으로 $344](https://www.wolfram.com/mathematica-home-edition/)이지만, **또한** [$35 라즈베리 파이를 구매하면 무료](https://www.wolfram.com/raspberry-pi/)입니다. 분명히 저는 라즈베리 파이를 샀고, 여러분도 같은 것을 하도록 권장합니다. 그것으로 무엇을 *하고* 싶은지만 알면 Mathematica가 여러분을 위해 할 수 있습니다. 그리고 수학이 어떻게 생겼는지 알아내기 위해 천재일 필요는 없습니다. 그것이 우리가 컴퓨터를 가진 이유입니다.

</div>

그렇다면 파란색으로 그려진 모든 곡선에 대한 표준 형식을 표준 맵에 겹쳐서 보여주는 스케치를 작성하여, 맵에서 네 번째 좌표가 어디에 있는지에 따라 곡선이 어떤 특징을 가져야 하는지 즉시 알 수 있도록 합시다.

<graphics-element title="표준 형식으로 매핑된 3차 곡선" width="800" height="400" src="./interactive.js"></graphics-element>
