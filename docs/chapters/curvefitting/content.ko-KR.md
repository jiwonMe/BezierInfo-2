# 곡선 맞추기

이전 섹션을 고려하면, 한 가지 질문이 있을 수 있습니다. "`t` 값을 추측하고 싶지 않다면요?". 결국 많은 그래픽 패키지가 자동 곡선 맞추기를 수행하므로, 자체적으로 합리적인 `t` 값을 찾는 방식으로 어떻게 구현할 수 있을까요?

그리고 실제로 이것은 "이 X개 점을 통과하는 곡선을 어떻게 얻나요?"라는 질문의 변형일 뿐이므로, 그것을 살펴봅시다. 구체적으로 답을 봅시다. "곡선 맞추기". 이것은 실제로 데이터 모델링에서 경로 추상화, "그리기"에 이르기까지 모든 것에 적용되는 기하학에서 상당히 풍부한 분야이므로, 곡선 맞추기를 수행하는 방법이 상당히 많지만 가장 일반적인 접근 방식 중 하나를 살펴보겠습니다. [최소 제곱](https://en.wikipedia.org/wiki/Least_squares) [다항식 회귀](https://en.wikipedia.org/wiki/Polynomial_regression)라는 것입니다. 이 접근 방식에서는 데이터 세트에 있는 점의 수를 보고, 이 점들에 맞는 곡선에 적절한 차수가 무엇인지 대략 결정한 다음, "`n`차 곡선을 원한다고 할 때, 곡선을 구축하면 곡선이 모든 원래 점을 통과하도록 찾을 수 있는 좌표는 무엇인가?"라는 질문을 다룹니다. 또는 그것이 실패하면 가능한 한 0에 가까운 전체 오차 거리를 갖습니다.

이제 점이 곡선에서 얼마나 "벗어났는지" 결정하는 방법은 많으며, 여기서 "최소 제곱" 용어가 나옵니다. 도구 상자에서 가장 일반적인 도구는 우리가 가진 각 점과 결국 "발명"하는 곡선의 해당 점 사이의 _제곱 거리_를 최소화하는 것입니다. 꼭 맞는 곡선은 이 둘 사이의 거리가 0이고 나쁜 맞춤은 모든 쌍 사이에 0이 아닌 거리가 있습니다. 작동 가능한 메트릭입니다. 거리가 양수 값인지 확인하는 것만으로도(총 오차를 거리를 합산하는 것만으로 쉽게 계산할 수 있도록) 충분하지 않고 왜 제곱해야 하는지 궁금할 수 있으며, 답은 실제로 "더 나은 경향이 있기 때문입니다"입니다. 최소 제곱 오차 메트릭 대 최소 절대 오차 메트릭의 특정 장점에 대해 깊이 파고들고 싶다면 웹에 많은 문헌이 있지만, 이것들은 이 자료의 범위를 <em>훨씬</em> 벗어납니다.

그렇다면 최소 제곱 베지에 맞추기를 수행한다는 아이디어로 시작하면 곡선 맞추기 측면에서 무엇을 얻게 되는지 살펴봅시다. Jim Herold가 그의 ["Least Squares Bézier Fit"](https://web.archive.org/web/20180403213813/http://jimherold.com/2012/04/20/least-squares-bezier-fit/) 기사에 설명한 것과 유사한 절차를 따르고 곡선 맞추기를 수행하기 위한 멋진 인터랙티브 그래픽으로 끝낼 것입니다.

시작하기 전에 행렬 형태의 곡선을 사용할 것입니다. [행렬 섹션](#matrix)에서 미적분 형태가 아니라 베지에 곡선의 행렬 표현을 사용하면 일부 작업이 더 쉽다고 언급했으며, 이것이 그러한 작업 중 하나입니다.

따라서 프로세스의 첫 번째 단계는 베지에 함수를 확장하여 베지에 곡선을 거듭제곱/계수/좌표 행렬 **T x M x C**로 표현하는 것입니다.

<div class="note">

## 행렬 표현 다시 보기

베지에 함수를 행렬 형태로 다시 쓰는 것은 먼저 함수를 확장한 다음 여러 줄 형태로 배열하면 상당히 쉽습니다. 각 줄은 t의 거듭제곱에 해당하고 각 열은 특정 계수에 해당합니다. 먼저 함수를 확장합니다.

\[
  \begin{aligned}
    B_{\textit{quadratic}} & = a (1-t)^2 + 2 b (1-t) t + c t^2 \\
                  & = a - 2at + at^2 + 2bt - 2bt^2 + ct^2
  \end{aligned}
\]

그런 다음 (사소하게) 여러 줄에 걸쳐 항을 재배열합니다.

\[
  \begin{aligned}
    B_{\textit{quadratic}} &=& a      &         &     \\
                  & & - 2at  & + 2bt   &     \\
                  & & + at^2 & - 2bt^2 & + ct^2
  \end{aligned}
\]

이 재배열에는 각 행에 "t의 인수"가 있고(첫 번째 행은 t⁰, 즉 "1", 두 번째 행은 t¹, 즉 "t", 세 번째 행은 t²) 각 열에 "계수"가 있습니다(첫 번째 열은 "a"와 관련된 모든 항, 두 번째는 "b"와 관련된 모든 항, 세 번째는 "c"와 관련된 모든 항).

이 배열로 이것을 행렬 곱셈으로 쉽게 분해할 수 있습니다.

\[
  \begin{aligned}
    B_{\textit{quadratic}} &= T \cdot M \cdot C
      =
      \begin{bmatrix}1 & t & t^2 \end{bmatrix}
      \cdot
      \begin{bmatrix}
         a &+&  0 &+& 0 \\
       -2a &+& 2b &+& 0 \\
         a &+&-2b &+& c
      \end{bmatrix}
      =
      \begin{bmatrix}1 & t & t^2 \end{bmatrix}
      \cdot
      \begin{bmatrix}
         1 & 0 & 0 \\
        -2 & 2 & 0 \\
         1 &-2 & 1
      \end{bmatrix}
      \cdot
      \begin{bmatrix}a  \\ b \\ c \end{bmatrix}
  \end{aligned}
\]

물론 3차 곡선에 대해서도 같은 작업을 수행할 수 있습니다. 3차에 대한 기저 함수를 알고 있습니다.

\[
  \begin{aligned}
    B_{\textit{cubic}} & = & a(1-t)^3 + 3b(1-t)^2 t + 3c(1-t)t^2 + dt^3
  \end{aligned}
\]

따라서 확장을 작성하고 재배열합니다.

\[
  \begin{aligned}
    B_{\textit{cubic}} & = & a        &          &          &   \\
              &   & - 3at    & + 3bt    &          &   \\
              &   & + 3at^2  & - 6bt^2  & +3ct^2   &   \\
              &   & - at^3   & + 3bt^3  & -3ct^3   & + dt^3
  \end{aligned}
\]

그런 다음 분해할 수 있습니다.

\[
  \begin{aligned}
    B_{\textit{cubic}} &= T \cdot M \cdot C =
      \begin{bmatrix}1 & t & t^2 & t^3 \end{bmatrix}
      \cdot
      \begin{bmatrix}
        1 & 0 & 0 & 0 \\
       -3 & 3 & 0 & 0 \\
        3 &-6 & 3 & 0 \\
       -1 & 3 &-3 & 1
      \end{bmatrix}
      \cdot
      \begin{bmatrix}a  \\ b \\ c \\ d \end{bmatrix}
  \end{aligned}
\]

그리고 물론 4차 곡선에 대해서도 할 수 있습니다(확장 단계 건너뛰기).

\[
  \begin{aligned}
    B_{\textit{quartic}} &= T \cdot M \cdot C =
      \begin{bmatrix}1 & t & t^2 & t^3 & t^4 \end{bmatrix}
      \cdot
      \begin{bmatrix}
        1 &   0 &   0 &  0 & 0 \\
       -4 &   4 &   0 &  0 & 0 \\
        6 & -12 &   6 &  0 & 0 \\
       -4 &  12 & -12 &  4 & 0 \\
        1 &  -4 &   6 & -4 & 1
      \end{bmatrix}
      \cdot
      \begin{bmatrix}a  \\ b \\ c \\ d \\ e \end{bmatrix}
  \end{aligned}
\]

그리고 계속 계속. 이제 이러한 **T**, **M**, **C**를 사용하여 곡선 맞추기를 수행하는 방법을 봅시다.

</div>

시작합시다. 올바른 차수 곡선을 선택했다고 가정하겠습니다. `n`개의 점에 대해 `n-1`차 곡선을 맞추고 있으므로, 이미 알고 있고 곡선 맞추기를 수행하려는 좌표를 나타내는 벡터 **P**로 "시작"합니다.

\[
  P = \begin{bmatrix} p_1 \\ p_2 \\ ... \\ p_n \end{bmatrix}
\]

다음으로 "실제 좌표"를 "곡선 위의 어떤 점"에 묶을 수 있는 무언가가 필요하므로 곡선의 각 점에 대한 적절한 `t` 값을 알아내야 합니다. 이를 수행하는 다양한 방법이 있으며("완벽한 맞춤"을 최적화하는 큰 부분은 적절한 `t` 값을 선택하는 것에 관한 것입니다), 이 경우 두 가지 "명백한" 선택을 살펴보겠습니다.

1. 균등하게 간격을 둔 `t` 값, 그리고
2. 다각형을 따라 거리와 정렬되는 `t` 값.

첫 번째는 정말 간단합니다. `n`개의 점이 있다면 각 점 `i`에 `(i-1)/(n-1)`의 `t` 값을 할당하기만 하면 됩니다. 따라서 네 점이 있다면 첫 번째 점은 `t=(1-1)/(4-1)=0/3`, 두 번째 점은 `t=(2-1)/(4-1)=1/3`, 세 번째 점은 `t=2/3`, 마지막 점은 `t=1`을 갖습니다. 우리가 가진 점의 수와 일치하도록 `t` 값을 직접 간격을 둡니다.

두 번째는 조금 더 흥미롭습니다. 다항식 회귀를 수행하고 있으므로 기본 좌표가 선분 모음을 구성한다는 사실을 활용할 수 있습니다. 첫 번째 점에서 t=0으로 고정하고 마지막 점에서 t=1을 원하며, 그 사이 어디든지 `t`가 [0,1] 도메인으로 확대/축소된 다각형을 따라 가는 거리와 같다고 간단히 말할 것입니다.

이 값을 얻으려면 먼저 일반 "다각형을 따라 가는 거리" 행렬을 계산합니다.

\[
  D = \begin{bmatrix}d_1 & d_2 & ... & d_n \end{bmatrix}, \textit{ where }
  \left \{
  \begin{matrix}
    d_1 = 0 \\
    d_i = d_{i-1} + \textit{length}(p_{i-1}, p_i)
  \end{matrix}
  \right.
\]

여기서 `length()`는 문자 그대로 그것입니다. 우리가 보고 있는 점과 이전 점 사이의 선분의 길이입니다. 물론 이것만으로는 충분하지 않습니다. `i=1`과 `i=n` 사이의 모든 값이 [0,1] 구간에 들어가도록 해야 하므로 다각형의 총 길이가 무엇이든 모든 값을 축소해야 합니다.

\[
  \begin{aligned}
    S = \begin{bmatrix}s_1 & s_2 & ... & s_n \end{bmatrix}, \textit{ where }
  \left \{
  \begin{matrix}
    s_1 = 0 \\
    s_i = d_i / d_n \\
    s_n = 1
  \end{matrix}
  \right.
  \end{aligned}
\]

이제 실제 "곡선 맞추기" 부분으로 이동할 수 있습니다. 우리가 원하는 것은 "이상적인" 제어점 값을 계산하여 그것들로 베지에 곡선을 구축하면 곡선이 모든 원래 점을 통과하도록 하는 함수입니다. 또는 그것이 실패하면 가능한 한 0에 가까운 전체 오차 거리를 갖습니다. 그렇다면 오차 거리가 어떻게 생겼는지 써봅시다.

앞서 언급했듯이 이 함수는 실제로 "실제 좌표와 연관된 `t` 값에 대해 곡선이 평가하는 좌표 사이의 거리"일 뿐이며, 성가신 음수 부호를 제거하기 위해 제곱합니다.

\[
  E(C)_i = \left ( p_i - \textit{Bézier}(s_i) \right )^2
\]

이 함수는 개별 좌표만 다루므로 전체 오차 함수를 얻기 위해 모든 좌표에 대해 합산해야 합니다. 따라서 문자 그대로 그렇게 합니다. 총 오차 함수는 단순히 이러한 모든 개별 오차의 합입니다.

\[
  E(C) = \sum^n_{i=1} \left ( p_i - \textit{Bézier}(s_i) \right )^2
\]

그리고 여기에 행렬 사용을 정당화하는 트릭이 있습니다. 미적분을 사용하여 개별 값으로 작업할 수 있지만 행렬을 사용하면 행렬을 만드는 만큼의 값을 "동시에" 모두 계산할 수 있습니다. 개별 항 p<sub>i</sub>를 전체 **P** 좌표 행렬로 바꿀 수 있고, Bézier(s<sub>i</sub>)를 이전에 이야기한 행렬 표현 **T x M x C**로 바꿀 수 있습니다.

\[
  E(C) = \left ( P - TMC \right )^2
\]

여기서 다소 번거로운 "제곱" 연산을 더 일반적인 행렬 등가물로 바꿀 수 있습니다.

\[
  E(C) = \left ( P - TMC \right )^T \left ( P - TMC \right )
\]

여기서 문자 `T`는 숫자 2 대신 [행렬 전치](https://en.wikipedia.org/wiki/Transpose)를 나타내는 데 사용됩니다. 원래 행렬의 각 행이 대신 전치된 행렬의 열이 됩니다(1행이 1열이 되고, 2행이 2열이 되는 식).

이것은 한 가지 문제를 남깁니다. **T**는 실제로 우리가 원하는 행렬이 아닙니다. 기호 `t` 값이 아니라 **S**에 대해 계산한 실제 숫자 값을 원하므로, 그것들을 사용하는 새 행렬을 형성해야 하며, 이를 𝕋라고 부르고 오차 함수에서 **T** 대신 그 𝕋를 사용합니다.

\[
𝕋 = \begin{bmatrix}
 s^0_1 & s^1_1 & ... & s^{n-2}_1 & s^{n-1}_1 \\
       &       &     &     &        \\
\vdots &       & ... &     & \vdots \\
       &       &     &     &        \\
 s^0_n & s^1_n & ... & s^{n-2}_n &  s^{n-1}_n
\end{bmatrix}
\]

**S**의 첫 번째 및 마지막 값 때문에 다음을 의미합니다.

\[
𝕋 = \begin{bmatrix}
 1      &       0 & ... &             0 &             0 \\
 1      &     s_2 &    &     s^{n-2}_2 &     s^{n-1}_2 \\
 \vdots &         & ... &               &        \vdots \\
 1      & s_{n-1} &    & s^{n-2}_{n-1} & s^{n-1}_{n-1} \\
 1      &       1 & ... &             1 &             1
\end{bmatrix}
\]

이제 오차 함수를 행렬 연산으로 제대로 쓸 수 있습니다.

\[
  E(C) = \left ( P - 𝕋MC \right )^T \left ( P - 𝕋MC \right )
\]

따라서 오차 함수가 있습니다. 이제 그 함수가 최소값을 갖는 곳, 즉 진정한 좌표와 곡선 맞추기에 의해 생성된 좌표 사이의 오차가 가장 작은 곳에 대한 표현을 알아내야 합니다. 표준 미적분과 마찬가지로 이를 위해서는 도함수를 취하고 그 도함수가 0인 곳을 결정해야 합니다.

\[
  \frac{\partial E}{\partial C} = 0 = -2𝕋^T \left ( P - 𝕋MC \right )
\]

<div class="note">

## 이 도함수는 어디서 왔나요?

그것은... 좋은 질문입니다. 사실 이 접근 방식을 실행하려고 할 때 같은 질문에 부딪혔습니다! 그리고 아시나요? 전혀 몰랐습니다. 미적분도 괜찮고, 선형 대수학도 괜찮지만, 그냥 모릅니다.

그래서 무언가를 이해하지 못할 때 항상 하는 일을 했습니다. 누군가에게 상황이 어떻게 작동하는지 이해하도록 도와달라고 요청했습니다. 이 특정 경우에 [Math.stackexchange](https://math.stackexchange.com)에 [질문을 게시](https://math.stackexchange.com/questions/2825438/how-do-you-compute-the-derivative-of-a-matrix-algebra-expression)했고, 받기를 희망했던 것보다 훨씬 더 자세한 답변을 받았습니다.

그 답변이 여러분에게 유용한가요? 아마도: 아니요. 적어도 여가 수준에서 수학을 이해하는 것을 좋아하지 않는 한. 그리고 저는 기본 대수학만이 아니라 일반적으로 수학을 의미합니다. 하지만 "잠깐. 왜 그게 사실이었나요?"라고 궁금해할 경우를 대비해 참조를 제공하는 데 도움이 됩니다. 답이 있습니다. 이해하는 데 시간이 좀 필요할 수 있습니다.

</div>

이제 위의 도함수가 주어지면 (행렬 대수학의 규칙을 따라) 항을 재배열하여 **C**에 대한 표현으로 끝낼 수 있습니다.

\[
  C = M^{-1} \left ( 𝕋^T 𝕋 \right )^{-1} 𝕋^T P
\]

여기서 "마이너스 1 거듭제곱"은 [행렬 역행렬](https://en.wikipedia.org/wiki/Invertible_matrix)에 대한 표기법입니다. 하지만 그것이 우리가 해야 할 전부입니다. 끝났습니다. **P**로 시작하고 **P**의 좌표가 정의하는 다각형을 기반으로 일부 `t` 값을 발명하여 점을 통과하는 곡선을 지정하는 해당 베지에 좌표 **C**를 계산할 수 있습니다. 또는 정확히 통과할 수 없다면 가능한 한 가까이.

그렇다면 시도하기 전에 이것을 구현하는 데 얼마나 많은 코드가 관련되나요? 솔직히 그 답은 직접 작성할 것이 얼마나 되는지에 달려 있습니다. 이미 행렬 수학 라이브러리를 사용할 수 있다면 실제로 그다지 많은 코드가 아닙니다. 반면에 처음부터 작성하는 경우 행렬 작업을 수행하기 위한 유틸리티 함수를 작성해야 하므로 실제로 50줄의 코드에서 200줄의 코드까지입니다. 사전 지정된 좌표에 곡선을 맞출 수 있는 것에 대해 나쁜 대가가 아닙니다.

그럼 시도해봅시다! 다음 그래픽을 사용하면 점을 배치할 수 있으며 최소 3개를 배치하면 정확 맞춤 곡선 계산을 시작합니다. 더 많은 점을 클릭하면 코드가 단순히 적절한 차수의 베지에 곡선을 사용하여 정확한 맞춤을 계산하려고 시도합니다. 4점? 3차 베지에. 5점? 4차. 그리고 계속. 물론 이것은 어느 시점에서 무너집니다. 점을 배치하는 위치에 따라 맞추기가 정확한 맞춤을 찾기가 매우 어려워질 수 있으며, 복합 [부동 소수점 반올림 오류](https://en.wikipedia.org/wiki/Round-off_error#Floating-point_number_system)가 차이를 만들기 시작할 만큼 충분한 점이 있으면 실제로 끔찍하게 벗어나기 시작할 수 있습니다(약 10~11점 정도).

<graphics-element title="베지에 곡선 맞추기" width="550" src="./curve-fitting.js" >
  <button class="toggle">toggle</button>
  <!-- additional sliders will get created on the fly -->
</graphics-element>

등거리 `t` 값과 점이 형성하는 다각형을 따라 가는 거리 비율 사이를 전환할 수 있는 편리한 "toggle" 버튼이 있다는 것을 알 수 있습니다. 더 흥미로운 것은 곡선을 추상화할 점이 있으면 각각에 대한 슬라이더를 통해 시간 값에 대한 <em>직접 제어</em>도 얻을 수 있다는 것입니다. 시간 값이 자유도라면 자유롭게 조작하고 곡선에 미치는 영향을 볼 수 있어야 하기 때문입니다.
