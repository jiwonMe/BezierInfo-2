# 원호와 3차 베지에

3차 베지에를 사용하여 원과 원호를 근사하는 것을 살펴봅시다. 얼마나 더 나을까요?

<graphics-element title="3차 베지에 호 근사" width="400" height="400" src="./arc-approximation.js">
  <input type="range" min="-3.1415" max="3.1415" step="0.01" value="1.4" class="slide-control">
</graphics-element>

얼핏 보면 상당히 더 나아 보이지만, 베지에 곡선을 구성하는 방법을 살펴봄으로써 _얼마나_ 더 나은지 알아봅시다.

![원호의 3차 근사를 위한 구성 다이어그램](images/chapter-assets/circles/image-20210417165543902.png)

시작점과 끝점은 사소하지만 중간점은 약간의 작업이 필요하지만, 원호에 대한 각도 θ를 알면 대부분 기본 삼각법입니다. 원호를 단위 원으로 확대/축소하면 항상 반경 1인 호를 (1,0)에서 시작할 수 있고, 호 각도 θ가 주어지면 원호가 길이 θ를 가진다는 것도 알 수 있습니다(단위 원은 그런 면에서 멋집니다). 끝점도 알고 있는데, 그것은 그냥 (cos(θ), sin(θ))이고, 따라서 과제는 _t_=0.5에서 곡선이 각도 θ/2에서 원호를 정확히 만지기 위해 어떤 제어점이 필요한지 알아내는 것입니다.

그렇다면 다시 공식적으로 설명해봅시다.

\[
\begin{aligned}
  P_1 &= (1, 0) \\
  P_2 &= (1, k) \\
  P_3 &= P_4 + k \cdot (sin(θ), -cos(θ)) \\
  P_4 &= (cos(θ), sin(θ))
\end{aligned}
\]

P<sub>3</sub>만 여기서 꽤 간단하지 않으며, 그 설명은 삼각형(원점, P<sub>4</sub>, P<sub>3</sub>)이 직각 삼각형이고 원점과 P<sub>4</sub> 사이의 거리가 1이며(단위 원으로 작업하고 있으므로), P<sub>4</sub>와 P<sub>3</sub> 사이의 거리가 _k_라는 사실에 기반합니다. 따라서 P<sub>3</sub>을 "점 P<sub>4</sub> 더하기 원점에서 P<sub>4</sub>까지의 벡터이지만 4분원만큼 반시계 방향으로 회전하고 _k_로 확대/축소됨"으로 나타낼 수 있습니다.

이를 통해 A, B, e<sub>1</sub>, e<sub>2</sub>에 대한 _y_ 좌표를 결정할 수 있으며, 그 후 _k_의 값이 무엇인지 결정하는 데 필요한 모든 정보를 갖게 됩니다. A가 P<sub>2</sub>와 P<sub>3</sub> 사이 중간에 있고, e<sub>1</sub>이 A와 "P<sub>1</sub>과 P<sub>2</sub> 사이 중간"("반 높이" P<sub>2</sub>) 사이에 있기 때문에, (여기서 놀랍지 않게) 알려진 점 사이의 선형 보간을 사용하여 이 값을 찾을 수 있습니다.

\[
\begin{aligned}
A_y &= \frac{P_{2_y} + P_{3_y}}{2} = \frac{k + sin(θ) - k \cdot cos(θ)}{2} \\
e_{1_y} &= \frac{A_y + \frac{1}{2}P_{2_y}}{2} = \frac{\frac{k + sin(θ) - k \cdot cos(θ)}{2} + \frac{k}{2}}{2} = \frac{2k + sin(θ) + k \cdot cos(θ)}{4} \\
e_{2_y} &= \frac{A_y + \textit{mid}(P_4, P_3)}{2} = \frac{A_y + sin(θ) - \frac{k}{2} cos(θ)}{2} = \frac{k + 3sin(θ) - 2k \cdot cos(θ)}{4} \\
B_y &= \frac{e_{1_y} + e_{2_y}}{2} = \frac{3k + 4sin(θ) - 3k \cdot cos(θ)}{8}
\end{aligned}
\]

이제 B에 대한 두 가지 항등식이 생겼습니다. 선형 보간을 통해 B를 결정하는 것 외에도 B의 _y_ 좌표가 그냥 _sin(θ/2)_라는 것도 알고 있기 때문입니다. 호의 반각에서 단위 원을 만지는 중간점인 점 B를 가진 베지에 곡선을 사용하여 원호를 근사하겠다고 말하면서 이 연습을 시작했으며, 정의에 의해 B를 점 (cos(θ/2), sin(θ/2))으로 만듭니다.

이것은 이제 B<sub>y</sub>에 대해 가진 두 항등식을 동등하게 만들고 _k_를 풀 수 있다는 것을 의미합니다.

<div class="note">

## _k_ 도출

_k_를 푸는 것은 상당히 간단하지만 꽤 많은 단계이며, 즉각적인 결과만 원한다면: [Wolfram Alpha](https://www.wolframalpha.com/)와 같은 도구를 사용하는 것이 확실히 가는 길입니다. 그렇다고 해도 진행해봅시다.

\[
\begin{aligned}
\frac{3k + 4sin(θ) - 3k \cdot cos(θ)}{8} &= sin(\frac{θ}{2}) \\
3k + 4sin(θ) - 3k \cdot cos(θ)  &= 8sin\left(\frac{θ}{2}\right) \\
3k - 3k \cdot cos(θ) &= 8sin\left(\frac{θ}{2}\right) - 4sin(θ) \\
3k (1 - cos(θ)) &= 4 \left ( 2sin\left(\frac{θ}{2} \right) - sin(θ) \right ) \\
3k &= 4 \cdot \frac{2sin(\frac{θ}{2}) - sin(θ)}{1 - cos(θ)}  \\
k &= \frac{4}{3} \cdot \frac {2sin\left(\frac{θ}{2}\right) - sin(θ)}{1 - cos(θ)}
\end{aligned}
\]

마지막으로 여러 삼각 항등식을 더 활용하여 _k_에 대한 공식을 _극적으로_ 단순화할 수 있습니다.

\[
\begin{aligned}
k &= \frac{4}{3} \cdot \frac {2sin\left(\frac{θ}{2}\right) - sin(θ)}{1 - cos(θ)}\\
k &= \frac{4}{3} \cdot \left ( \frac {2sin\left(\frac{θ}{2}\right)}{1 - cos(θ)} - \frac {sin(θ)}{1 - cos(θ)} \right )\\
k &= \frac{4}{3} \cdot \left (csc\left(\frac{θ}{2}\right)  - cot\left(\frac{θ}{2}\right) \right )\\
k &= \frac{4}{3} \cdot tan\left ( \frac{θ}{4} \right )\\
\end{aligned}
\]

끝났습니다.

</div>

따라서 제어점에서 시작/끝 점까지의 거리는 원호의 각도와 관련된 거의 사소한 표현에서 얻는 숫자로 표현할 수 있습니다.

\[
k = f(θ) = \frac{4}{3} tan\left (\frac{θ}{4} \right )
\]

즉, 각도 θ와 반경 _r_을 가진 모든 원호에 대해 세 개의 입사점을 기반으로 한 베지에 근사는 다음과 같습니다.

\[
\begin{aligned}
\textit{start} &= (r,~0) \\
\textit{control}_{~1} &= (r,~k) \\
\textit{control}_{~2} &= r\cdot(cos(θ) + k \cdot sin(θ), sin(θ) - k \cdot cos(θ)) \\
\textit{end} &= r \cdot (cos(θ),~sin(θ))
\end{aligned}
\]

이것은 또한 반 π의 각도를 가지므로 4분원에 대해 일반적으로 발견되는 0.55228 값을 제공합니다.

\[
f\left ( \frac{\pi}{2} \right ) = \frac{4}{3} \cdot tan\left(\frac{\pi}{8}\right) = \frac{4}{3}(\sqrt{2}-1)\approx 0.55228474983[...]
\]

따라서 반경 _r_의 4분원에 대한 다음 베지에 좌표를 제공합니다.

\[
\begin{aligned}
\textit{start} &= (r,~0) \\
\textit{control}_{~1} &= (r,~0.55228 \cdot r) \\
\textit{control}_{~2} &= (0.55228 \cdot r,~r) \\
\textit{end} &= (0,~r)
\end{aligned}
\]

<div class="note">

## 그래서, 이것은 얼마나 정확한가요?

2차 곡선과 달리 <i>t=0.5</i>를 참조점으로 사용할 수 없습니다. 본질적으로 실제로 원호 자체에 있도록 보장되는 세 점 중 하나이기 때문입니다. 대신 최대 편차를 제공할 다른 <i>t</i> 값이 필요합니다. 두 가지 가능한 선택이 있지만(곡선이 여전히 엄밀히 원호를 "초과"하고 대칭적이기 때문) 완벽한 _t_ 값을 찾기 위해 미적분을 사용하려고 시도하는 대신—할 수 있습니다! 컴퓨터를 사용할 수 있는 한 수학은 완벽하게 합리적입니다—가장 큰 편차에 대해 이진 검색을 수행하고 이 모든 수학 작업을 신경 쓰지 않을 수도 있습니다.

그럼 대신 그렇게 해봅시다. 일부 거친 간격으로 0에서 1까지 _t_를 통해 실행하고, "무리 중에서 가장 높은 편차"를 가진 _t_ 값을 찾은 다음, 그 _t_ 값 주위의 훨씬 더 작은 간격으로 같은 검사를 다시 실행하여 임의로 정확한 _t_ 값을 얻기 위해 필요한 만큼 반복하는 최대 편차 검사를 실행할 수 있습니다.

```
getMostWrongT(radius, bezier, start, end, epsilon=1e-15):
  if end-start < epsilon:
    return (start+end)/2
  worst_t = 0
  max = 0
  stepsize = (end-start)/10
  for t=start to end, using stepsize:
    p = bezier.get(t)
    diff = p.magnitude() - radius
    if diff > max:
      worst_t = t
      max = diff
  return getMostWrongT(radius, bezier, worst_t - stepsize, worst_t + stepsize)
```

게다가 그 이름으로 함수를 작성할 기회가 얼마나 자주 있나요?

이 코드를 사용하면 _t_ 값이 대략 0.211325와 0.788675라는 것을 알 수 있으므로, 둘 중 낮은 것을 선택하고 원래 2차 오차가 녹색으로 표시된 각도 도메인에 걸쳐 최대 편차가 무엇인지 봅시다(먼저 무한대로 급등한 다음 2π에 접근하면서 다시 내려옴).

<table><tbody><tr><td>
  <img src="images/chapter-assets/circles/image-20210417173811587.png" width="95%"/>
</td><td>
  <img src="images/chapter-assets/circles/image-20210417174019035.png" width="95%"/>
</td><td>
  <img src="images/chapter-assets/circles/image-20210417174100036.png" width="95%"/>
</td></tr>
<tr><td>
  0 ≤ φ ≤ 2π에 대해 플롯된 오차
</td><td>
  0 ≤ φ ≤ π에 대해 플롯된 오차
</td><td>
  0 ≤ φ ≤ ½π에 대해 플롯된 오차
</td></tr>
</tbody></table>

마지막 이미지는 아마도 충분히 명확하지 않습니다. 4분원의 3차 근사는 2차 곡선과 같은 스케일에서 실제로 볼 수 없을 정도로 엄청나게 더 좋습니다. y축을 조금 확대하고 다시 시도해봅시다.

<p style="text-align: center"><img src="images/chapter-assets/circles/image-20210417174215876.png" height="350px"></p>

네... 4분원에 대한 3차 근사의 오차는 _두 자릿수_ 더 나은 것으로 밝혀졌습니다. 약 0.00027(또는: 반경 10,000픽셀인 원에 대해 2.7픽셀 벗어나는 것보다 약간 적음)에서 2차 곡선에 비해 정밀도 증가는 꽤 극적입니다. 확실히 제정신인 사람이라면 2차 곡선을 사용해서는 안 될 만큼 충분히 좋습니다.

</div>

그래서 그게 전부입니다. 카파는 _4/3 · tan(θ/4)_ , 끝났습니다! ...아니면 끝났나요?

## 더 잘할 수 있나요?

기술적으로: 네, 할 수 있습니다. 하지만 "할 수 있고, 그 가능성을 조사해야 하지만, 값을 하드 코딩할 경우에만 결과가 _더_ 낫다는 것을 미리 경고하겠습니다"로 이 섹션을 시작하겠습니다. 우리는 잡초 속으로 들어가려고 하고 표준 세 점 입사 값이 이미 너무 좋아서 대부분의 애플리케이션에서 더 잘하려고 하는 것은 전혀 의미가 없습니다.

그렇다고 해도: 위에서 계산한 것은 원호에 대한 최적 맞춤 베지에 곡선의 _상한_입니다. 근사에서 원호를 만지지 않는 곳은 어디든 호를 "초과"했습니다. _k_ 값을 조금만 낮추어 곡선이 과대평가로 시작하지만 원호를 교차하여 과소평가 영역을 산출한 다음 원호를 다시 교차하여 또 다른 과대평가 영역을 만들면 어떻게 될까요? 이것은 전체 오차를 낮출 수 있으므로 무엇을 할 수 있는지 봅시다.

먼저 표준 미적분 표기법을 사용하여 총 오차(원호 각도 θ와 일부 _k_가 주어진)를 표현해봅시다.

\[
\textit{erf}~(θ, k) = \int_0^1{\left \| \sqrt{B_x(t,θ,k)^2 + B_y(t,θ,k)^2} - r \right \|dt}
\]

이것은 주어진 각도와 _k_ 값에 대한 오차 함수가 연속 _t_ 값 사이에 무한히 작은 단계 크기를 사용하여 _t_를 0에서 1까지 실행하면서 곡선과 원호 사이의 차이의 "무한" 합과 같다고 말합니다.

이제 최소 오차를 찾고 싶으므로 이 함수를 따라 "오차가 점진적으로 줄어드는" 것에서 "오차가 다시 증가"하는 것으로 변하는 곳을 알고 싶다는 것을 의미하며, 이는 도함수가 0인 곳을 알고 싶다는 것을 의미하며, 수학적 표현으로는 다음과 같습니다.

\[
\left ( \int_0^1{\left \| \sqrt{B_x^2 + B_y^2} - r \right \|dt} \right ) \frac{d}{dt} = 0
\]

여기에 [미적분학의 기본 정리](https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus)의 가장 직접적인 적용이 있습니다. 도함수와 적분은 서로의 역연산이므로 서로를 상쇄하여 원래 함수를 남깁니다.

\[
\left \| \sqrt{B_x^2 + B_y^2} - r \right \| = 0, ~~ t \in [0,1]
\]

이제 그것을 풀기만 하면... 오 잠깐. 이전에 본 적이 있습니다. 이것을 풀기 위해 다음을 풀어야 합니다.

\[
B_x^2 + B_y^2 = r
\]

그리고 등호 왼쪽의 두 항은 모두 6차 다항식이며, 호 길이 섹션에서 다루었듯이 [이 방정식에 대한 기호 해는 없습니다](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem). 대신 여기서 해를 찾기 위해 수치적 접근 방식을 사용해야 하므로... 컴퓨터로!

<div class="note">

## 해에 대한 반복

실제로 의미하는 것은 "이진 검색 알고리즘으로"입니다. 합리적으로 잘 작동하는 함수를 다루고 있기 때문입니다. _k_ 값에 따라 평균적으로 "호의 중심에서 거리 _r_이 아닌", "정확히 호의 중심에서 거리 _r_인", 또는 "호의 중심에서 거리 _r_보다 큰" 베지에 곡선으로 끝날 것이므로, 중간 케이스를 얻는 가장 정확한 _c_ 값으로 이진 검색할 수 있습니다.

먼저 이진 검색에 들어가기 전에 상한과 하한을 결정하는 설정입니다.

```
findBest(radius, angle, points[]):
  lowerBound = 0
  upperBound = 4.0/3.0 * Math.tan(abs(angle) / 4)
  return binarySearch(radius, angle, points, lowerBound, upperBound)
```

그런 다음 거의 모든 CS 교과서와 평생 읽을 수 있는 것보다 더 많은 온라인 기사, 튜토리얼, 블로그 게시물에서 찾을 수 있는 이진 검색 알고리즘입니다.

```
binarySearch(radius, angle, points[], lowerBound, upperBound, epsilon=1e-15):
  value = (upperBound + lowerBound)/2

  if (upperBound - lowerBound < epsilon) return value

  // 현재 "value"를 기반으로 제어점 다시 계산
  d = (points[3].y < 0 ? -1 : 1) * value * radius
  points[1] = new Point(radius, d)
  points[2] = new Point(
    points[3].x + d * sin(angle)
    points[3].y - d * cos(angle)
  )

  if radialError(radius, points) > 0:
    // 베지에 곡선이 원하는 것보다 깁니다: 상한 감소
    return binarySearch(radius, angle, points, lowerBound, value)
  else:
    // 베지에 곡선이 원하는 것보다 짧습니다: 하한 증가
    return binarySearch(radius, angle, points, value, upperBound)
```

여러 점에 걸쳐 곡선의 원호 근사를 샘플링하는 다음 `radialError` 함수를 사용합니다(첫 번째와 마지막 점은 절대 기여하지 않으므로 건너뜁니다).

```
radialError(radius, points[]):
  err = 0
  steps = 5.0
  for (int i=1; i<steps; i++):
    Point p = getOnCurvePoint(points, i/steps)
    err += p.magnitude()/radius - 1
  return err
```

여기서 `getOnCurvePoint`는 점을 산출하는 표준 베지에 평가 함수일 뿐입니다. 그 점을 벡터로 취급하면 `magnitude` 호출을 사용하여 원점까지의 길이를 얻을 수 있습니다.

## 결과 검사

위 코드를 실행하면 0에서 π까지 각도 θ 목록과 연관된 _k_ 값 목록을 얻을 수 있으며, 이를 사용하여 각 각도에 대해 원호와 베지에 근사 사이의 차이가 어떻게 보이는지 플롯할 수 있습니다.

![image-20210419085430711](images/chapter-assets/circles/image-20210419085430711.png)

여기서 _t_를 0에서 1까지 실행하면서 호와 베지에 근사 사이의 차이가 플롯된 것을 볼 수 있습니다. 플롯만 봐도 _t_ = 0.5에서 최대 편차가 있다는 것을 알 수 있으므로, 0에서 θ까지 각도에 대한 최대 편차 "함수"를 플롯해봅시다.

사실 θ에 대한 함수로 두 접근 방식 모두에 대한 최대 편차를 플롯해봅시다.

<table><tbody><tr><td>
  <img src="images/chapter-assets/circles/image-20210418111929371.png" width="95%"/>
</td><td>
  <img src="images/chapter-assets/circles/image-20210418112008676.png" width="95%"/>
</td><td>
  <img src="images/chapter-assets/circles/image-20210418112038613.png" width="95%"/>
</td></tr>
<tr><td>
  단위 스케일을 사용한 최대 편차
</td><td>
  10배 스케일에서 최대 편차
</td><td>
  100배 스케일에서 최대 편차
</td></tr>
</tbody></table>

실제로 그다지 더 나아 보이지 않으므로, 실제 개선이 무엇인지 보기 위해 몇 가지 숫자를 봅시다.

| angle | "improved" deflection | "upper bound" deflection | difference            |
| ----- | --------------------- | ------------------------ | --------------------- |
| 1/8 π | 6.202833502388927E-8  | 6.657161222278773E-8     | 4.5432771988984655E-9 |
| 1/4 π | 3.978021202111215E-6  | 4.246252911066506E-6     | 2.68231708955291E-7   |
| 3/8 π | 4.547652269037972E-5  | 4.8397483513262785E-5    | 2.9209608228830675E-6 |
| 1/2 π | 2.569196199214696E-4  | 2.7251652752280364E-4    | 1.559690760133403E-5  |
| 5/8 π | 9.877526288810667E-4  | 0.0010444175859711802    | 5.666495709011343E-5  |
| 3/4 π | 0.00298164978679627   | 0.0031455628414580605    | 1.6391305466179062E-4 |
| 7/8 π | 0.0076323182807019885 | 0.008047777909948373     | 4.1545962924638413E-4 |
| π     | 0.017362185964043708  | 0.018349016519545902     | 9.86830555502194E-4   |

보시다시피 정밀도 증가는 특별히 크지 않습니다. 4분원(π/2)의 경우 전통적인 _k_는 반경 10,000픽셀인 원에서 2.75픽셀 벗어나는 반면, 이 "더 나은" 맞춤은 2.56픽셀 벗어납니다. 그리고 그것은 확실히 거의 10% 개선이지만, 눈에 띄는 차이를 만들기에 충분한 개선과는 거리가 멉니다.

</div>

이 시점에서 개선이 있을 수 있지만 본질적으로 중요하지 않으면서 _훨씬_ 더 계산적으로 비쌀 수 있다는 것이 분명해야 합니다.

## TL;DR: 사용해야 하는 값만 알려주세요

무엇을 해야 하는지에 달려 있습니다. 4분원에 대한 최상의 값만 원하고 _k_ 값을 하드 코딩할 경우 상수 `k=4/3*tan(pi/8)`를 하드 코딩하는 대신 상수를 `k=0.551784777779014`로 하드 코딩할 이유가 없습니다.

**4분원에 대한 "그" 값이 필요하면 0.55228 대신 0.551785를 사용하세요**

그러나 대신 베지에 경로를 사용하여 원형 경로를 맞추려고 시도하는 코드에서 동적 호 근사의 경우, 접선 계산, 두 개의 나눗셈, 하나의 곱셈을 포함하는 간단한 함수가 25% 낮은 오차 값을 얻기 위해 작성한 모든 코드를 실행하는 것보다 훨씬 더 성능이 좋으며, "더 정확한" 값을 얻는 것보다 확실히 선호할 가치가 있다는 것이 상당히 명백해야 합니다.

**즉석에서 원호에 베지에를 맞춰야 하는 경우 `4/3 * tan(θ/4)`를 사용하세요**

그러나 인간을 위해 작성하는 경우 일반적으로 두 세계의 최고를 사용할 수 있다는 것을 항상 기억하세요. 사용자가 곡선과 상호 작용할 때 근사를 그리는 대신 _그들의 곡선_을 그려야 합니다. 원이나 원호를 그려야 하는 경우 그것들을 그리고, 데이터를 지원하지 않는 형식으로 내보내야 할 때만 베지에 곡선으로 근사하세요. 이상적으로는 오차가 어디에 있고 얼마나 클지 강조하는 미리보기 메커니즘이 있어야 합니다.

**인간의 그래픽 디자인을 위한 코드를 작성하는 경우 원호에 대해서는 원호를 사용하세요**

그리고 그게 전부입니다. 이 주제를 꽤 잘 소진했습니다. "다른 최상의 _k_ 값"을 찾기 위해 사용할 수 있는 다른 메트릭이 있습니다. 예를 들어 호 길이를 일치시키려고 시도하거나(예: 재료 비용을 최적화할 때), 원호와 베지에 곡선 사이의 면적을 최소화하거나(예: 잉킹을 최적화할 때), 베지에 곡률의 변화율을 최소화하는(예: 곡선 순회를 최적화할 때) 등이 있으며, 모두 너무 유사한 값을 산출하여 거의 확실히 가치가 없습니다. (예를 들어 4분원 근사의 경우 이 값들은 각각 0.551777, 0.5533344, 0.552184입니다. 최대 편차를 최소화하여 얻는 0.551785와 마찬가지로 이러한 값 중 어느 것도 상한 값보다 선호할 만큼 충분히 더 좋지 않습니다).
