# 3D 법선 작업하기

다음 섹션으로 넘어가기 전에 2D와 3D의 차이에 대해 약간의 시간을 할애해야 합니다. 많은 것들에 대해 이 차이는 관련이 없고 절차가 동일하지만(예를 들어 3D 접선을 얻는 것은 2D에 대해 하는 것을 하되, x와 y만이 아니라 x, y, z에 대해 하는 것입니다), 법선의 경우 상황이 조금 더 복잡하고 따라서 더 많은 작업이 필요합니다. 물론 "엄청 어렵지"는 않지만 더 많은 단계가 관련되어 있으므로 살펴봐야 합니다.

3D에서 법선을 얻는 것은 원칙적으로 2D에서와 같습니다. 정규화된 접선 벡터를 가져와서 4분의 1 회전만큼 회전합니다. 그러나 여기서 상황이 조금 더 복잡해집니다. 3D에서 "법선"은 단일 벡터가 아니라 평면이므로 꽤 많은 방향으로 회전할 수 있으므로 기본적으로 3D 경우에서 "그" 법선이 무엇인지 정의해야 합니다.

"순진한" 접근 방식은 [Frenet 법선](https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas)으로 알려진 것을 구성하는 것입니다. 여기서 많은 경우에 작동하는 간단한 레시피를 따릅니다(하지만 일부 다른 경우에는 엄청나게 이상한 일을 합니다). 아이디어는 접선에 수직인 벡터(즉, 90도 각도를 만드는)가 무한히 많지만, 접선 자체가 이미 자체 평면에 어느 정도 놓여 있다는 것입니다. 곡선의 각 점(아무리 밀접하게 간격이 띄워져 있더라도)에는 자체 접선 벡터가 있으므로, 각 점이 지역 접선과 같은 평면에 있을 뿐만 아니라 "바로 옆에" 있는 접선과도 같은 평면에 있다고 말할 수 있습니다.

접선 벡터의 차이가 미미하더라도 "모든 차이"는 그 평면이 무엇인지, 또는 오히려 그 평면에 수직인 벡터가 무엇인지 알아내는 데 필요한 전부입니다. 그것이 우리가 필요한 것입니다. 그 벡터를 계산할 수 있고 평면에 놓여 있다는 것을 알고 있는 접선 벡터가 있다면, 접선 벡터를 수직 위로 회전할 수 있고, 프레스토. 2D 경우에 사용한 것과 같은 논리를 사용하여 법선을 계산했습니다. "그냥 90도 회전하면 됩니다".

그럼 그렇게 해봅시다! 그리고 반전 서프라이즈로, 네 줄로 할 수 있습니다.

- **a** = normalize(B'(t))
- **b** = normalize(**a** + B''(t))
- **r** = normalize(**b** × **a**)
- **normal** = normalize(**r** × **a**)

조금 풀어봅시다.

- 곡선의 어떤 점에서 도함수에 대한 [정규화된 벡터](https://en.wikipedia.org/wiki/Unit_vector)를 가져오는 것으로 시작합니다. 수학이 덜 작업이 되도록 정규화합니다. 덜 작업은 좋습니다.
- 그런 다음 곡선이 우리 점에서 변화를 멈추고 그 점부터 같은 도함수와 2차 도함수를 가지기만 한다면 다음 점의 접선이 어떻게 될지 나타내는 **b**를 계산합니다.
- 이를 통해 같은 평면에 놓인 두 벡터(도함수, 그리고 도함수에 추가된 2차 도함수)를 찾을 수 있으며, 이는 [외적](https://en.wikipedia.org/wiki/Cross_product)이라는 기본 벡터 연산을 사용하여 그 평면에 수직인 벡터를 계산할 수 있음을 의미합니다. (그 연산이 × 연산자를 사용하지만 곱셈은 절대 아닙니다!) 그 결과는 2D 경우에서 했던 것처럼 접선을 4분원 회전시켜 법선을 얻기 위한 "회전 축"으로 사용할 수 있는 벡터를 제공합니다.
- 외적을 사용하면 다른 두 벡터로 정의된 어떤 평면에 수직인 벡터를 찾을 수 있고, 법선 벡터는 접선과 회전 축이 놓인 평면에 수직이어야 하므로, 외적을 두 번째로 사용하여 즉시 법선 벡터를 얻을 수 있습니다.

그리고 끝났습니다. 3D 곡선에 대한 "그" 법선 벡터를 찾았습니다. 샘플 곡선에 대해 어떻게 보이는지 봅시다, 그렇죠? 커서 위치를 기반으로 하는 t 값을 가진 점에서 법선을 보여주기 위해 그래픽을 왼쪽에서 오른쪽으로 커서를 이동할 수 있습니다. 왼쪽 끝은 0, 오른쪽 끝 = 1, 중간은 t=0.5 등입니다.

<graphics-element title="알려진 벡터와 알려지지 않은 벡터" width="350" height="300" src="./frenet.js">
  <input type="range" min="0" max="1" step="0.01" value="0" class="slide-control">
</graphics-element>

하지만 그 그래픽을 약간 가지고 놀았다면 이상한 것을 알아챘을 수 있습니다. 법선이 t=0.65와 t=0.75 사이에서 "갑자기 곡선 주위로 비틀리는" 것 같습니다... 왜 그럴까요?

알고 보니 수학이 작동하는 방식이 그렇기 때문에 그렇게 하는 것이고, 그것이 Frenet 법선의 문제입니다. "수학적으로 올바르지만" "실제로 문제가 있으므로" 모든 종류의 그래픽 작업에서 우리가 정말로 원하는 것은 그냥... 보기 좋은 법선을 계산하는 방법입니다.

다행히도 Frenet 법선이 유일한 옵션은 아닙니다.

또 다른 옵션은 약간 더 알고리즘적인 접근 방식을 취하고 [Rotation Minimising Frame](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/Computation-of-rotation-minimizing-frames.pdf)("평행 이동 프레임" 또는 "Bishop 프레임"으로도 알려짐)의 형태를 대신 계산하는 것입니다. 여기서 "프레임"은 곡선 위의 점을 중심으로 하는 접선, 회전 축, 법선 벡터로 구성된 집합입니다.

이러한 유형의 프레임은 "이전 프레임"을 기반으로 계산되므로, Frenet 프레임에 대해 할 수 있었던 것처럼 단일 점에 대해 "요청 시" 단순히 계산할 수 없습니다. 전체 곡선에 대해 계산해야 합니다. 다행히도 절차는 꽤 간단하며 곡선에 대한 조회 테이블을 구축하는 동시에 수행할 수 있습니다.

아이디어는 t=0에서 시작 "접선/회전 축/법선" 프레임을 가져온 다음, 보기 좋은 다음 프레임을 산출하는 규칙을 적용하여 다음 프레임이 "어떻게 생겨야" 하는지 계산하는 것입니다. 위에 링크된 RMF 논문의 경우 그 규칙은 다음과 같습니다.

- RM 프레임을 이미 알고 있는 곡선 위의 점을 가져오고,
- RM 프레임을 아직 모르는 곡선 위의 다음 점을 가져오고,
- 다음 점과 이전 점 사이 정확히 중간 지점에서 곡선을 통과하는 평면을 "거울"로 취급하여 알려진 프레임을 다음 점에 반사합니다.
- 이렇게 하면 다음 점에 본질적으로 반대 방향을 가리키는 접선 벡터와 약간 기울어진 법선이 생기므로:
- "미러링된 프레임"의 벡터를 두 번째로 반사하되, 이번에는 "다음 점" 자체를 통과하는 평면을 "거울"로 사용합니다.
- 완료: 접선과 법선이 수정되었고, 작업할 보기 좋은 프레임이 생겼습니다.

그럼, 그것을 위한 코드를 작성해봅시다!

<div class="howtocode">

### Rotation Minimising Frames 구현

먼저 위에서 이미 논의한 점에서 Frenet 프레임을 계산하는 함수가 있다고 가정하며, 다음 속성을 가진 프레임을 산출하는 방식으로:

```
{
  o: 모든 벡터의 원점, 즉 곡선 위의 점,
  t: 접선 벡터,
  r: 회전 축 벡터,
  n: 법선 벡터
}
```

그런 다음 다음과 같은 방식으로 RM 프레임 시퀀스를 생성하는 함수를 작성할 수 있습니다.

```
generateRMFrames(steps) -> frames:
  step = 1.0/steps

  // t=0에서 곡선과 연관된 표준 접선/축/법선 프레임으로 시작:
  frames.add(getFrenetFrame(0))

  // RM 프레임 구성 시작:
  for t0 = 0, t0 < 1.0, t0 += step:
    // 이전에 알려진 프레임으로 시작
    x0 = frames.last

    // 다음 프레임 가져오기: 위치와 접선을 유지하되,
    // 축과 법선은 다시 계산할 것입니다.
    t1 = t0 + step
    x1 = { o: getPoint(t1), t: getDerivative(t) }

    // 먼저 x0와 x1 사이 지점의 반사 평면을 통해
    // x0의 접선과 회전 축을 x1에 반사합니다
    v1 = x1.o - x0.o
    c1 = v1 · v1
    riL = x0.r - v1 * 2/c1 * v1 · x0.r
    tiL = x0.t - v1 * 2/c1 * v1 · x0.t

    // v1은 벡터이지만 2/c1과 (v1 · ...)는 그냥
    // 일반 숫자이므로 상수로 v1을 확대/축소하는 것뿐입니다.

    // 그런 다음 x1의 평면에서 두 번째로 반사하여
    // 프레임 접선이 곡선 접선과 다시 정렬되도록 합니다:
    v2 = x1.t - tiL
    c2 = v2 · v2

    // 그리고 여기서 끝났습니다:
    x1.r = riL - v2 * 2/c2 * v2 · riL
    x1.n = x1.r × x1.t
    frames.add(x1)
```

주석을 무시하면, 이것은 단일 Frenet 프레임을 계산할 때보다 확실히 더 많은 코드이지만, 훨씬 더 보기 좋은 법선을 얻기 위한 미친 양의 코드는 아닙니다.

</div>

보기 좋은 것에 대해 말하자면, 이것이 실제로 어떻게 보일까요? 이전 곡선을 다시 봅시다, 하지만 이번에는 Frenet 프레임이 아니라 회전 최소화 프레임을 사용합니다.

<graphics-element title="알려진 벡터와 알려지지 않은 벡터" width="350" height="300"  src="./rotation-minimizing.js">
  <input type="range" min="0" max="1" step="0.01" value="0" class="slide-control">
</graphics-element>

훨씬 더 좋아 보입니다!

코드와 함께 읽는 사람들을 위해: 엄밀히 말해서 시작하기 위해 Frenet 프레임이 필요하지 않습니다. 예를 들어 z축을 초기 회전 축으로 취급하여 초기 법선이 **(0,0,1) × tangent**가 되도록 한 다음 거기서 시작할 수 있지만, 초기 법선이 3D 공간에서 곡선의 방향을 기반으로 정렬되는 것처럼 보이도록 초기 "수학적으로 올바른" 프레임을 갖는 것이 그냥 좋습니다.
