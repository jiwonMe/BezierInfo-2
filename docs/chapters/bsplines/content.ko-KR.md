# B-Spline

베지에 곡선에 대한 논의는 곡선 디자인 공간의 또 다른 야수인 B-Spline을 언급하지 않고는 완료될 수 없습니다. 베지에 스플라인을 의미한다고 쉽게 혼동되지만 실제로는 그렇지 않습니다. "기저 함수" 스플라인이며 이것은 큰 차이를 만듭니다. 이 섹션에서 그러한 차이를 살펴보겠습니다. 베지에 곡선에 대해 했던 것만큼 깊이 B-Spline을 다루지는 않을 것이지만(그것은 그 자체로 완전한 입문서가 될 것입니다) B-Spline이 어떻게 작동하는지, 계산에 어떤 종류의 수학이 관련되는지, 개별 B-Spline에 대해 선택할 수 있는 여러 매개변수를 기반으로 그리는 방법을 살펴보겠습니다.

먼저: B-Spline은 [구간별](https://en.wikipedia.org/wiki/Piecewise) [다항식 보간 곡선](https://en.wikipedia.org/wiki/Spline_(mathematics))이며, "단일 곡선"은 고정된 수의 점의 슬라이딩 윈도우를 사용하여 점 집합에 대해 다항식 보간을 수행하여 구축됩니다. 예를 들어 12개의 점으로 정의된 "3차" B-Spline은 4개 점의 다항식 보간을 평가하여 곡선이 구축되며, 곡선은 한 번에 4개 점으로 제어되는 많은 다른 섹션으로 취급될 수 있습니다. 따라서 전체 곡선은 점 {1,2,3,4}, {2,3,4,5}, ..., {8,9,10,11}, 마지막으로 {9,10,11,12}로 정의된 부드럽게 연결된 8개 섹션으로 구성됩니다.

어떻게 생겼을까요? 이렇게 생겼습니다! 그래픽을 탭하여 더 많은 점을 추가하고 점을 이동하여 스플라인 곡선에 어떻게 매핑되는지 확인하세요.

<graphics-element title="B-Spline 예제" width="600" height="300" src="./basic.js"></graphics-element>

여기서 주목해야 할 중요한 부분은 B-Spline으로 다중 베지에나 Catmull-Rom 곡선에 대해 하는 것과 **같은** 일을 하지 않는다는 것입니다. 후자 둘은 단순히 새 섹션을 문자 그대로 "새 점을 기반으로 한 새 섹션"으로 정의하므로 12점 3차 다중 베지에 곡선은 실제로 불가능합니다. 4점 곡선으로 시작한 다음 뒤따르는 각 섹션에 대해 3개 점을 더 추가하기 때문에 4, 7, 10, 13, 16 등 점 다중 베지에만 가질 수 있습니다. 마찬가지로 Catmull-Rom 곡선은 단일 점을 추가하여 성장할 수 있지만, 이 단일 점의 추가는 세 개의 암시적 베지에 점을 도입합니다. 반면 3차 B-Spline은 *네 개의 연속 점을 포함하는 각 가능한 곡선*의 부드러운 보간이므로 시작점과 끝점을 제외한 곡선을 따라 모든 점에서 곡선 위의 좌표가 네 개의 제어점으로 정의됩니다.

차이를 다음과 같이 생각하세요.

- 베지에 곡선의 경우 곡선은 점의 보간으로 정의되지만:
- B-Spline의 경우 곡선은 *곡선*의 보간으로 정의됩니다.

사실 다시 봅시다, 하지만 이번에는 기저 곡선도 함께 표시합니다. 연속된 각 네 점은 하나의 곡선을 정의합니다.

<graphics-element title="B-Spline의 성분" width="600" height="300" src="./basic.js" data-show-curves="true">
  <!-- basis curve highlighter goes here -->
</graphics-element>

이 곡선의 보간이 작동하도록 하기 위해 수학은 필연적으로 베지에 곡선의 수학보다 더 복잡하므로 상황이 어떻게 작동하는지 살펴봅시다.

## B-Spline 곡선 계산 방법: 약간의 수학

차수 `d`이고 따라서 차수 `k=d+1`인 B-Spline(따라서 2차 B-Spline은 차수 2이고 차수 3, 3차 B-Spline은 차수 3이고 차수 4 등)과 `n`개의 제어점 `P<sub>0</sub>` ~ `P<sub>n-1</sub>`이 주어지면, [0,1] 구간의 어떤 값 `t`에 대한 곡선 위의 점을 다음 함수를 평가하여 계산할 수 있습니다(여기서 0은 곡선의 시작, 1은 끝입니다, 베지에 곡선과 마찬가지로).

\[
  Point(t) = \sum^n_{i=0} P_i \cdot N_{i,k}(t)
\]

솔직히 이것은 우리에게 그다지 많은 것을 알려주지 않습니다. B-Spline 곡선의 점이 "어떻게든 가중치가 적용된 모든 제어점의 혼합"으로 정의된다는 것만 볼 수 있으며, 가중치는 *N(...)* 함수를 통해 달성됩니다. 명백한 매개변수 `i`(합산에서 나옴)와 마법의 매개변수 `k`로 아래 첨자가 붙습니다. 따라서 두 가지를 알아야 합니다. 1. N(t)가 무엇을 하는지, 2. 그 `k`가 무엇인지. 둘 다 역순으로 다루겠습니다.

매개변수 `k`는 곡선의 섹션이 정의되는 "노트 간격"을 나타냅니다. 앞서 배웠듯이 B-Spline 곡선 자체는 곡선의 보간이며, 제어점이 총 곡률에 영향을 미치기 시작하거나 중지하는 각 전환을 "곡선의 노트"로 취급할 수 있습니다. `n`개의 제어점이 있는 차수 `d` B-Spline에 대해 이렇게 하면 `d + n + 1`개의 노트가 제공되어 곡선을 따라 `d + n`개의 간격을 정의하며, 위의 N() 함수에 대한 `k` 아래 첨자가 적용되는 것이 바로 이 간격입니다.

그런 다음 N() 함수 자체입니다. 어떻게 생겼을까요?

\[
  N_{i,k}(t) =
    \left ( \frac{t-\textit{knot}_i}{\textit{knot}_{(i+k-1)} - \textit{knot}_i}\right )
    \cdot
    N_{i,k-1}(t) +
    \left ( \frac{\textit{knot}_{(i+k)}-t}{\textit{knot}_{(i+k)} - \textit{knot}_{(i+1)}} \right )
    \cdot
    N_{i+1,k-1}(t)
\]

여기서 보간을 볼 수 있습니다. `(i,k)` 쌍(즉, 위 합산의 단계, 특정 노트 간격에서)에 대한 N(t)는 `(i,k-1)`에 대한 N(t)와 `(i+1,k-1)`에 대한 N(t) 사이의 혼합이므로 이것이 `i`가 올라가고 `k`가 내려가는 재귀 반복이며, 이 재귀가 어느 시점에서 중지해야 한다고 예상하는 것이 합리적으로 보입니다. 분명히 그렇고, 구체적으로 다음 `i`/`k` 값에 대해 그렇게 합니다.

\[
  N_{i,1}(t) = \left\{\begin{matrix}
               1 & \textit{if } t \in [\textit{knot}_i,\textit{knot}_{i+1}) \\
               0 & \textit{otherwise}
               \end{matrix}\right.
\]

그리고 이 함수는 마침내 직접적인 평가를 합니다. `k=1` 값에 도달하면 `t` 값이 노트별 간격 내에 있으면 "세어지고", 그렇지 않으면 세어지지 않습니다. 하지만 약간 속였습니다. 이 모든 값에 대해 먼저 `t` 값을 확대/축소하여 `knots[d]`와 `knots[n]`으로 제한된 구간에 놓이도록 해야 하기 때문입니다. 이것들은 곡률이 정확히 `order` 제어점으로 제어되는 시작점과 끝점입니다. 예를 들어 차수 3(=차수 4)과 7개의 제어점, 노트 벡터 [1,2,3,4,5,6,7,8,9,10,11]의 경우 `t`를 [구간 0,1]에서 구간 [4,8]로 매핑한 다음 위 함수에서 그 값을 대신 사용합니다.

## 단순화할 수 있나요?

할 수 있습니다, 네.

우리보다 훨씬 똑똑한 사람들이 이 작업을 살펴봤고, 특히 두 명([Maurice Cox](https://www.npl.co.uk/people/maurice-cox)와 [Carl de Boor](https://en.wikipedia.org/wiki/Carl_R._de_Boor))이 수학적으로 만족스러운 해결책에 도달했습니다. 점 P(t)를 계산하기 위해 노트 `i`와 `i+1` 사이의 곡선 섹션에서 *d(t)*를 평가하여 이 점을 계산할 수 있습니다.

\[
  d^k_i(t) = \alpha_{i,k} \cdot d^{k-1}_i(t) + (1-\alpha_{i,k}) \cdot d^{k-1}_{i-1}(t)
\]

이것은 또 다른 재귀 함수이며, *k* 값이 곡선 차수에서 1로 감소하고, 값 *α*(알파)는 다음으로 정의됩니다.

\[
  \alpha_{i,k} = \frac{t - \textit{knots}[i]}{\textit{knots}[i+1+n-k] - \textit{knots}[i]}
\]

복잡해 보이지만 그렇지 않습니다. 알파를 계산하는 것은 알려진 일반 숫자와 관련된 분수일 뿐입니다. 그리고 알파 값이 있으면 사소한 빼기이므로 `(1-alpha)`도 있습니다. 따라서 `d()` 함수를 계산하는 것은 대부분 꽤 간단한 산술 문장을 계산하는 문제이며, 재귀할 때 참조할 수 있도록 결과를 캐싱합니다. 재귀가 계산적으로 비용이 많이 들 수 있지만, 각 단계에는 매우 간단한 수학만 포함되므로 전체 알고리즘은 저렴합니다.

물론 재귀에는 중지 조건이 필요합니다.

\[
  d^k_0(t) = 0, ~d^0_i(t) = N_{i,1}(t) =
  \left\{\begin{matrix}
    1 & \textit{if } t \in [\textit{knot}_i,\textit{knot}_{i+1}) \\
    0 & \textit{otherwise}
  \end{matrix}\right.
\]

따라서 실제로 두 가지 중지 조건을 볼 수 있습니다. `i`가 0이 되면 `d()`는 0이거나, `k`가 0이 되면 위의 N() 함수에서 본 것과 같은 "1 또는 0"을 얻습니다.

Cox와 de Boor 덕분에 드 카스텔죠 알고리즘에서 본 것과 같은 종류의 선형 보간을 사용하여 B-Spline 위의 점을 꽤 쉽게 계산할 수 있습니다. 예를 들어 `i=3`과 `k=3`에 대해 `d()`를 작성하면 다음 재귀 다이어그램을 얻습니다.

\[
  d^3_3 = \left \{
    \begin{aligned}
      \alpha^3_3 \times d^2_3, & ~\textit{ with } d^2_3 = \left \{
        \begin{aligned}
          \alpha^2_3 \times d^1_3, & ~\textit{ with } d^1_3 =
            \left \{
              \begin{aligned}
                \alpha^1_3 \times d^0_3, & ~\textit{ with } d^0_3 \textit{ either 0 or 1} \\
                + & \\
                \left ( 1 - \alpha^1_3 \right ) \times d^0_2, & ~\textit{ with } d^0_2 \textit{ either 0 or 1} \\
              \end{aligned}
            \right . \\
          + & \\
          \left ( 1 - \alpha^2_3 \right ) \times d^1_2, & ~\textit{ with } d^1_2 =
            \left \{
              \begin{aligned}
                \alpha^1_2 \times d^0_2 & \\
                + & \\
                \left ( 1 - \alpha^1_2 \right ) \times d^0_1, & ~\textit{ with } d^0_1 \textit{ either 0 or 1} \\
              \end{aligned}
            \right . \\
        \end{aligned}
      \right . \\
      + & \\
      \left ( 1 - \alpha^3_3 \right ) \times d^2_2, & ~\textit{ with } d^2_2 = \left \{
        \begin{aligned}
          \alpha^2_2 \times d^1_2 & \\
          & \\
          + & \\
          \left ( 1 - \alpha^2_2 \right ) \times d^1_1, & ~\textit{ with } d^1_1 =
            \left \{
              \begin{aligned}
                \alpha^1_1 \times d^0_1 \\
                + & \\
                \left ( 1 - \alpha^1_1 \right ) \times d^0_0, & ~\textit{ with } d^0_0 \textit{ either 0 or 1} \\
              \end{aligned}
            \right . \\
        \end{aligned}
      \right .
    \end{aligned}
  \right .
\]

즉, `d(3,3)`을 `d(2,3)`과 `d(2,2)`의 혼합으로 계산하며, 이 두 개는 각각 `d(1,3)`과 `d(1,2)`, 그리고 `d(1,2)`와 `d(1,1)`의 혼합입니다. 이것들은 자체적으로 기타 기타의 혼합입니다. 중지 조건에 도달할 때까지 항을 계속 확장한 다음 모든 것을 다시 합산합니다. 정말 꽤 우아합니다.

명심해야 할 한 가지는 제어점에 의해 제한된 스플라인으로 작업하고 있다는 것이므로, `d(..., k)` 값이 가장 낮은 수준에서 0 또는 1이더라도 실제로는 "0 또는 1, 곱하기 각각의 제어점"이므로 다음 섹션에서는 제어점 벡터의 복사본으로 시작하여 단일 점까지 작업하는 방식으로 계산을 실행하는 알고리즘을 보게 됩니다. 먼저 "왼쪽"에서 시작하여 "오른쪽"으로 작업한 다음 "왼쪽"으로 다시 합산하는 대신, 오른쪽에서 시작하여 즉시 왼쪽으로 작업할 수 있습니다.

## 계산 실행

드 카스텔죠 알고리즘과 달리 `t` 값이 모든 반복에서 동일하게 유지되는 것이 아니라, B-Spline의 경우 그렇지 않으므로 (평가하는 각 점에 대해) 상당히 관련된 재귀 계산을 실행해야 합니다. 알고리즘은 [이 Michigan Tech](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/de-Boor.html) 페이지에서 논의되지만, 읽기 쉬운 버전은 [b-spline.js](https://github.com/thibauts/b-spline/blob/master/index.js#L59-L71)에서 구현되므로 그 코드를 살펴보겠습니다.

입력 값 `t`가 주어지면 먼저 입력을 도메인 `[0,1]`에서 도메인 `[knots[degree], knots[knots.length - 1 - degree]`로 매핑합니다. 그런 다음 이 매핑된 `t` 값이 놓인 섹션 번호 `s`를 찾습니다.

```
for(s=domain[0]; s < domain[1]; s++) {
  if(knots[s] <= t && t <= knots[s+1]) break;
}
```

이 코드를 실행한 후 `s`는 점이 놓일 섹션의 인덱스입니다. 그런 다음 MU 페이지에 언급된 알고리즘을 실행합니다(이 설명의 변수 이름을 사용하도록 업데이트됨).

```
let v = copy of control points

for(let L = 1; L <= order; L++) {
  for(let i=s; i > s + L - order; i--) {
    let numerator = t - knots[i]
    let denominator = knots[i - L + order] - knots[i]
    let alpha = numerator / denominator
    let v[i] = alpha * v[i] + (1-alpha) * v[i-1]
  }
}
```

(이 코드의 멋진 동작은 보간을 "거꾸로" 작업하여 보간의 각 수준에서 `i=s`에서 시작하고 `i = s - order + level`일 때 중지하므로 항상 `v[i-1]`이 존재하지 않는 배열 인덱스를 사용하려고 하지 않는 `i` 값으로 끝납니다)

## 열린 경로 vs. 닫힌 경로

다중 베지에와 마찬가지로 B-Spline은 첫 번째 점에서 마지막 점까지 실행되는 열린 경로이거나, 첫 번째 점과 마지막 점이 같은 좌표인 닫힌 경로일 수 있습니다. 그러나 B-Spline은 점이 아니라 곡선의 보간이므로 단순히 첫 번째 점과 마지막 점을 같게 만들 수 없으며, 스플라인이 보간을 수행하는 "곡선"을 형성하는 데 필요한 만큼의 점을 연결해야 합니다. 따라서 차수 `d` B-Spline의 경우 첫 번째와 마지막 `d`개 점을 같게 만들어야 합니다. 이것은 물론 이전보다 거의 더 많은 작업이 아니지만(단순히 `points`에 `points.splice(0,d)`를 추가), 단일 점 이상이 필요하다는 것을 기억하는 것이 중요합니다.

물론 이러한 종류의 곡선을 조작하려면 "닫힘"으로 표시하여 `points[0]`과 `points[n-k]` 등에 대한 좌표가 우연히 같은 x/y 값을 갖는 것이 아니라 실제로 같은 좌표라는 것을 알 수 있도록 해야 합니다. 따라서 하나를 조작하면 다른 것도 똑같이 조작됩니다. 하지만 프로그래밍은 일반적으로 별도의 좌표 객체가 아니라 점에 대한 참조(또는 NURBS 섹션에서 논의된 좌표 가중치와 같은 다른 연결된 값)를 저장하여 이것을 정말 쉽게 만듭니다.

## 노트 벡터를 통한 곡선 조작

B-Spline과 관련하여 이해해야 할 가장 중요한 것은 노트 벡터의 개념 *때문에* 작동한다는 것입니다. 위에서 언급했듯이 노트는 "개별 제어점이 곡선에 영향을 미치기 시작/중지하는 곳"을 나타내지만 노트 벡터에 들어가는 *값*은 결코 살펴보지 않았습니다. N() 및 a() 함수를 되돌아보면 보간이 노트 벡터의 실제 값이 아니라 노트 벡터의 간격을 기반으로 한다는 것을 알 수 있으며, 이를 악용하여 노트 벡터의 영리한 조작으로 꽤 흥미로운 작업을 수행할 수 있습니다. 구체적으로 살펴볼 가치가 있는 네 가지가 있습니다.

1. 균등하게 간격을 둔 간격이 있는 균일 노트 벡터를 사용할 수 있습니다.
2. 균등하게 간격을 둔 간격을 강제하지 않고 비균일 노트 벡터를 사용할 수 있습니다.
3. 연속 노트를 같은 값으로 축소하여 "널" 간격을 사용하여 곡선 복잡도를 로컬로 낮출 수 있습니다.
4. (1)과 (3)을 결합하여 축소된 시작 및 끝 노트를 가진 벡터를 형성하고 그 사이에 균일 벡터를 가진 특수 케이스 비균일 벡터를 형성할 수 있습니다.

### 균일 B-Spline

가장 간단한 유형의 B-Spline은 균일 스플라인입니다. 균일 스플라인에서 노트는 전체 곡선 간격에 균일하게 분포됩니다. 예를 들어 길이가 12인 노트 벡터가 있다면 균일 노트 벡터는 [0,1,2,3,...,9,10,11]입니다. 또는 *같은 간격*을 정의하는 [4,5,6,...,13,14,15], 심지어 *같은 간격*을 정의하는 [0,2,3,...,18,20,22]도 있습니다. 상수 인수로 확대/축소되었을 뿐이며, 보간 중에 정규화되므로 곡률에 기여하지 않습니다.

<graphics-element title="균일 B-Spline" width="400" height="400" src="./uniform.js">
  <!-- knot sliders go here -->
</graphics-element>

이것은 중요한 점입니다. 노트 벡터가 정의하는 간격은 *상대적* 간격이므로 모든 간격이 크기 1이든 크기 100이든 상관없습니다. 간격 간의 상대적 차이가 특정 곡선을 형성하는 것입니다.

균일 노트 벡터의 문제는 보간을 수행할 수 있는 곡선을 갖기 전에 `order` 제어점이 필요하므로 곡선이 첫 번째 점에서 "시작"하지 않고 마지막 점에서 "끝나지" 않습니다. 대신 "간격"이 있습니다. 대신 다음 균일성 파괴 접근 방식을 영리하게 적용하여 이를 제거할 수 있습니다...

### 간격을 축소하여 지역 곡선 복잡도 줄이기

두 개 이상의 연속 노트가 같은 값을 갖도록 하여 노트 간격을 축소하면 관련된 노트의 영향을 받는 섹션에서 곡선 복잡도를 줄일 수 있습니다. 이것은 극적인 효과를 가질 수 있습니다. 모든 간격 축소에 대해 곡선 차수가 내려가고 곡선 연속성이 내려가서 `order` 노트를 축소하면 모든 연속성이 손실되고 곡선이 "꺾이는" 상황이 생성됩니다.

<graphics-element title="축소된 균일 B-Spline" width="400" height="400" src="./reduced.js">
  <!-- knot sliders go here -->
</graphics-element>

### 열린-균일 B-Spline

곡선의 시작과 끝에서 노트 간격 축소를 결합하고 그 사이에 균일 노트를 사용하여 곡선이 시작하고 끝나기를 원하는 곳에서 시작하고 끝나지 않는 문제를 극복할 수 있습니다.

제어점 `N`이 있는 차수 `D`의 모든 곡선에 대해 값 `0 ... D+1`이 같고, 값 `D+1 ... N+1`이 "균일" 패턴을 따르고, 값 `N+1 ... N+D+1`이 다시 같은 길이 `N+D+1`의 노트 벡터를 정의할 수 있습니다. 예를 들어 7개의 제어점이 있는 3차 B-Spline은 노트 벡터 [0,0,0,0,1,2,3,4,4,4,4]를 가질 수 있거나 "동일한" 노트 벡터 [0,0,0,0,2,4,6,8,8,8,8] 등을 가질 수 있습니다. 다시 말하지만 곡선 형태를 결정하는 것은 상대적 차이입니다.

<graphics-element title="열린 균일 B-Spline" width="400" height="400" src="./uniform.js" data-open="true">
  <!-- knot sliders go here -->
</graphics-element>

### 비균일 B-Spline

이것은 본질적으로 B-Spline의 "자유 형태" 버전이며, 특정 노트 간격을 선택할 특정 이유 없이는 특별히 흥미로운 일이 일어나지 않으므로 살펴보기에는 가장 흥미롭지 않습니다. 모든 값 `knots[k+1]`이 `knots[k]`보다 크거나 같아야 한다는 것 외에 노트 벡터에 대한 제약 조건이 하나 있습니다.

## 마지막 한 가지: 유리 B-Spline

B-Spline에 대한 이 섹션이 이미 꽤 길게 진행되고 있는 것이 사실이지만, 한 가지 더 이야기해야 할 것이 있으며, 그것은 "유리" 스플라인입니다. 여기서 유리성은 제어점 자체의 "비율" 또는 상대적 가중치에 적용됩니다. 각 제어점에 적용할 가중치가 있는 비율 벡터를 도입하여 최종 곡선 형태에 대한 영향력을 크게 높입니다. 제어점이 더 많은 가중치를 가질수록 스플라인 곡선은 그 점에 더 가까이 놓이며, 유리 베지에 곡선과 마찬가지로 제어점의 중력을 높이는 것과 비슷합니다.

<graphics-element title="(닫힌) 유리 균일 B-Spline" width="400" height="400" src="rational-uniform.js">
  <!-- knot sliders go here -->
</graphics-element>

물론 이것은 B-Spline에 대한 모든 텍스트가 하루를 마무리하기 전에 다뤄야 하는 최종 주제로 우리를 데려갑니다. [NURBS](https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline), 즉 비균일 유리 B-Spline(NURBS는 복수가 아니며, 대문자 S는 실제로 "spline"을 나타내지만 많은 사람들이 실수로 복수인 것처럼 취급하므로 이제 더 잘 알게 되었습니다). NURBS는 컴퓨터 지원 디자인에서 중요한 유형의 곡선이며, 3D 모델링(일반적으로 NURBS 표면으로)에서 많이 사용되며 NURBS 곡선이 디자이너에게 제공하는 제어 수준으로 인해 임의 정밀도 2D 디자인에서도 사용됩니다.

진정한 비균일 유리 B-Spline은 작업하기 어렵지만, NURBS에 대해 이야기할 때 일반적으로 열린-균일 유리 B-Spline 또는 OURBS를 의미하지만, 그것은 거의 멋지게 발음되지 않으므로 사람들이 NURBS에 대해 이야기할 때 일반적으로 열린-균일을 의미한다는 것을 기억하세요. 이것은 첫 번째 제어점에서 곡선을 시작하고 마지막에서 끝내는 유용한 속성을 가집니다.

## 유리 스플라인을 다루도록 구현 확장

유리 B-Spline으로 작업하기 위한 알고리즘은 일반 알고리즘과 사실상 동일하며, 제어점 가중치에서 작업하도록 확장하는 것은 상당히 간단합니다. 각 제어점을 원래 차원 수(2D, 3D 등)의 점에서 한 차원 더 높은 것으로 확장하고, 원래 차원을 제어점의 가중치로 확대/축소한 다음, 확장된 차원에 대한 값으로 그 가중치를 할당합니다.

예를 들어 가중치 `w`를 가진 2D 점 `(x,y)`는 3D 점 `(w * x, w * y, w)`가 됩니다.

그런 다음 이전과 같은 알고리즘을 실행하면 일반 좌표 보간 외에 가중치 보간도 자동으로 수행됩니다. 우리가 한 일은 더 높은 차원에 좌표가 있는 척했을 뿐이기 때문입니다. 알고리즘은 보간해야 하는 차원의 수에 대해 실제로 신경 쓰지 않습니다.

"실제" 곡선 점을 복구하기 위해 점 생성 알고리즘의 최종 결과를 가져와서 "가중치 해제"합니다. 최종 점의 파생 가중치 `w'`를 가져와서 모든 일반 좌표 차원을 그것으로 나눈 다음 가중치 정보를 버립니다.

이전 예제를 기반으로 최종 3D 점 `(x', y', w')`를 가져와서 `(x'/w', y'/w')`를 계산하여 2D 점으로 다시 바꿉니다. 그리고 그게 전부입니다, 끝났습니다!
