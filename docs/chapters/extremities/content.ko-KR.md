# 극값 찾기: 근 찾기

이제 (적어도 피상적으로는) 성분 함수를 이해했으니, B'(t) = 0 방정식을 풀어 성분 함수에서 최댓값과 최솟값을 찾아 베지에 곡선의 극값을 찾을 수 있습니다. 베지에 곡선의 도함수가 더 간단한 베지에 곡선이라는 것을 이미 봤지만, 등식을 어떻게 풀까요? 사실 꽤 쉽습니다. 도함수가 4차 이상이 될 때까지는... 그러면 정말 어려워집니다. 하지만 간단하게 시작해봅시다.

### 2차 곡선: 선형 도함수

2차 베지에 곡선의 도함수는 두 항 사이만 보간하는 선형 베지에 곡선이며, 이는 "이 선이 0인 곳은 어디인가"에 대한 해를 찾는 것이 `t`의 함수로 다시 쓰고 푸는 것으로 사실상 사소하다는 것을 의미합니다. 먼저 [도함수 섹션](#derivatives) 끝에 언급된 규칙을 따라 2차 베지에 함수를 선형 함수로 바꿉니다.

\[
\begin{aligned}
  B'(t) = a(1-t) + b(t) &= 0,\\
  a - at + bt &= 0,\\
  (b-a)t + a &= 0\\
\end{aligned}
\]

그런 다음 기본 산술을 사용하여 이것을 `t`에 대한 해로 바꿉니다.

\[
\begin{aligned}
  (b-a)t + a &= 0,\\
  (b-a)t &= -a,\\
  t &= \frac{-a}{b-a}\\
\end{aligned}
\]

끝났습니다.

단, `b-a`가 0이면 해가 없고 아마도 그 나눗셈을 수행하려고 하지 말아야 한다는 [주의 사항](https://en.wikipedia.org/wiki/Caveat_emptor#Caveat_lector)이 있습니다.

### 3차 곡선: 2차 공식

3차 베지에 곡선의 도함수는 2차 베지에 곡선이며, 2차 다항식의 근을 찾는다는 것은 [2차 공식](https://en.wikipedia.org/wiki/Quadratic_formula)을 적용할 수 있다는 것을 의미합니다. 이전에 본 적이 있다면 기억하실 것이고, 보지 못했다면 다음과 같습니다.

\[
  \textit{Given}~f(t) = at^2 + bt + c,~f(t)=0 ~\textit{when}~ t = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
\]

따라서 베지에 성분 함수를 일반 다항식으로 다시 쓸 수 있으면 끝입니다. 값을 2차 공식에 대입하고, 제곱근이 음수인지 아닌지 확인하고(음수이면 근이 없음), 나오는 두 값을 계산하기만 하면 됩니다(더하기/빼기 기호 때문에 두 개를 얻음). 0과 1 사이의 모든 값은 베지에 곡선에 중요한 근이며, 그 아래나 위의 것은 관련이 없습니다(베지에 곡선은 [0,1] 구간에서만 정의되기 때문). 그렇다면 어떻게 변환할까요?

먼저 [도함수 섹션](#derivatives) 끝에 언급된 규칙을 따라 3차 베지에 함수를 2차 함수로 바꿉니다.

\[
\begin{array}{l}
  B(t)~\textit{uses}~\{ p_1,p_2,p_3,p_4 \} \\
  B'(t)~\textit{uses}~\{ v_1,v_2,v_3 \},~\textit{where}~v_1 = 3(p_2-p_1),~v_2 = 3(p_3-p_2),~v_3 = 3(p_4-p_3)
\end{array}
\]

그런 다음 이러한 *v* 값을 사용하여 *a*, *b*, *c*가 무엇이어야 하는지 알아낼 수 있습니다.

\[
\begin{aligned}
  B'(t) &= v_1(1-t)^2 + 2v_2(1-t)t + v_3t^2 \\
  ... &= v_1(t^2 - 2t + 1) + 2v_2(t-t^2) + v_3t^2 \\
  ... &= v_1t^2 - 2v_1t + v_1 + 2v_2t - 2v_2t^2 + v_3t^2 \\
  ... &= v_1t^2 - 2v_2t^2 + v_3t^2 - 2v_1t + v_1 + 2v_2t \\
  ... &= (v_1-2v_2+v_3)t^2 + 2(v_2-v_1)t + v_1
\end{aligned}
\]

이것은 `v` 값으로 표현된 세 계수 {a, b, c}를 제공하며, `v` 값은 원래 좌표 값의 표현이므로 대입하여 다음을 얻을 수 있습니다.

\[
\begin{aligned}
  a &= v_1-2v_2+v_3 = 3(-p_1 + 3p_2 - 3p_3 + p_4) \\
  b &= 2(v_2-v_1) = 6(p_1 - 2p_2 + p_3) \\
  c &= v_1 = 3(p_2-p_1)
\end{aligned}
\]

아주 쉽습니다. 이제 이 값을 2차 공식에 대입하여 거의 사소하게 근을 찾을 수 있습니다.

그리고 3차 곡선으로서 의미 있는 2차 도함수도 있으며, 도함수의 도함수를 간단히 취하여 계산할 수 있습니다.

### 4차 곡선: Cardano 알고리즘

지금까지 실제로 살펴보지 않았지만, 다음 단계는 4차 베지에 곡선인 4차 곡선입니다. 예상대로 이것들은 3차 함수인 도함수를 가지며, 이제 상황이 훨씬 더 어려워집니다. 3차 함수에는 2차 공식처럼 근을 찾기 위한 "간단한" 규칙이 없으며, 대신 풀기 시작할 수 있는 형태로 상당한 재작성이 필요합니다.

16세기로 돌아가서, 베지에 곡선이 있기 전, 심지어 _미적분 자체_가 있기 전에, [Gerolamo Cardano](https://en.wikipedia.org/wiki/Gerolamo_Cardano)는 일반 3차 함수를 푸는 것이 정말 어렵더라도 근을 찾는 것이 "더 쉬운"(심지어 "쉬운"은 아니더라도) 형태로 다시 쓸 수 있다는 것을 알아냈습니다.

\[
  \begin{aligned}
    \textit{very hard: solve } & at^3 + bt^2 + ct + d = 0 \\
    \textit{easier: solve } & t^3 + pt + q = 0
  \end{aligned}
\]

더 쉬운 공식은 4개가 아니라 두 개의 상수만 있고, 3개가 아니라 `t`와 관련된 두 개의 표현만 있다는 것을 알 수 있습니다. 이것은 [일반 미적분](https://www.wolframalpha.com/input/?i=t^3+%2B+pt+%2B+q)을 사용하여 방정식을 만족하는 값을 찾을 수 있기 때문에 훨씬 쉽게 풀 수 있습니다.

이제 한 가지 작은 문제가 있습니다. 3차 함수로서 해가 일반 숫자가 아니라 [복소수](https://en.wikipedia.org/wiki/Complex_number)일 수 있습니다... 그리고 Cardano는 복소수가 수론의 잘 이해되고 확립된 부분이 되기 몇 세기 전에 이것을 깨달았습니다. 그의 해석은 "이 숫자들은 불가능하지만 나중 단계에서 다시 사라지므로 괜찮다"였으며, 그것들에 대해 너무 많이 생각하지 않도록 했지만, 우리는 훨씬 더 쉽습니다. 표시 목적으로 근을 찾으려고 하므로 복소수에 대해 신경 쓰지 _않습니다_. 일반 숫자가 아닌 솔루션을 버려 Cardano의 접근 방식을 조금 더 단순화할 것입니다.

그렇다면 어려운 공식을 더 쉬운 공식으로 어떻게 다시 쓸까요? 이것은 3차 방정식을 푸는 [Ken J. Ward의 페이지](https://trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm)에서 자세히 설명되므로, 수학을 보여주는 대신 3차 방정식을 푸는 프로그래밍 코드를 보여드리겠습니다. 복소근은 완전히 무시되지만, 관심이 있다면 Ken의 페이지로 가서 절차를 읽어보세요.

<div class="howtocode">

### 모든 실근을 찾기 위한 Cardano 알고리즘 구현

"실근" 부분은 상당히 중요합니다. "실수" 공간(ℝ로 표시)에서는 음수의 제곱근, 세제곱근 등을 취할 수 없지만, ["복소수"](https://en.wikipedia.org/wiki/Complex_number) 공간(ℂ로 표시)에서는 완전히 괜찮기 때문입니다. 그리고 우연히도 Cardano는 역사상 계산에 복소수를 사용한 최초의 수학자로도 알려져 있습니다. 바로 이 알고리즘을 위해!

```
// [0,1] 구간의 값을 필터링하는 헬퍼 함수:
function accept(t) {
  return 0<=t && t <=1;
}

// 실수 세제곱근만 함수:
function cuberoot(v) {
  if(v<0) return -pow(-v,1/3);
  return pow(v,1/3);
}

// 이제: 3차 좌표 {pa, pb, pc, pd}가 주어지면 모든 근 찾기
function getCubicRoots(pa, pb, pc, pd) {
  var   a = (3*pa - 6*pb + 3*pc),
        b = (-3*pa + 3*pb),
        c = pa,
        d = (-pa + 3*pb - 3*pc + pd);

  // 3차 풀이가 실제로 필요한지 확인:
  if (approximately(d,0)) {
    // 이것은 3차 곡선이 아닙니다.
    if (approximately(a,0)) {
      // 사실 이것은 2차 곡선도 아닙니다.
      if (approximately(b,0)) {
        // 사실 사실, 해가 없습니다.
        return [];
      }
      // 선형 해
      return [-c / b].filter(accept);
    }
    // 2차 해
    var q = sqrt(b*b - 4*a*c), 2a = 2*a;
    return [(q-b)/2a, (-b-q)/2a].filter(accept)
  }

  // 이 시점에서 3차 해가 필요하다는 것을 압니다.

  a /= d;
  b /= d;
  c /= d;

  var p = (3*b - a*a)/3,
      p3 = p/3,
      q = (2*a*a*a - 9*a*b + 27*c)/27,
      q2 = q/2,
      discriminant = q2*q2 + p3*p3*p3;

  // 나중에 사용할 변수:
  var u1, v1, root1, root2, root3;

  // 세 개의 가능한 실근:
  if (discriminant < 0) {
    var mp3  = -p/3,
    mp33 = mp3*mp3*mp3,
    r    = sqrt( mp33 ),
    t    = -q / (2*r),
    cosphi = t<-1 ? -1 : t>1 ? 1 : t,
    phi  = acos(cosphi),
    crtr = cuberoot(r),
    t1   = 2*crtr;
    root1 = t1 * cos(phi/3) - a/3;
    root2 = t1 * cos((phi+2*pi)/3) - a/3;
    root3 = t1 * cos((phi+4*pi)/3) - a/3;
    return [root1, root2, root3].filter(accept);
  }

  // 세 개의 실근, 하지만 두 개가 같음:
  if(discriminant === 0) {
    u1 = q2 < 0 ? cuberoot(-q2) : -cuberoot(q2);
    root1 = 2*u1 - a/3;
    root2 = -u1 - a/3;
    return [root1, root2].filter(accept);
  }

  // 하나의 실근, 두 개의 복소근
  var sd = sqrt(discriminant);
  u1 = cuberoot(sd - q2);
  v1 = cuberoot(sd + q2);
  root1 = u1 - v1 - a/3;
  return [root1].filter(accept);
}
```

</div>

그리고 그게 전부입니다. 수학은 복잡하지만 코드는 거의 "가능한 한 많은 값을 캐싱하여 재계산을 최대한 방지하면서 수학을 따르는" 것일 뿐이며, 이제 3차 함수에 대한 모든 근을 찾는 방법이 있으므로 곡선의 극값을 찾는 데 사용하여 계속 진행할 수 있습니다.

그리고 물론 4차 곡선도 의미 있는 2차 및 3차 도함수를 가지므로, 3차 곡선과 마찬가지로 도함수의 도함수(의 도함수)를 사용하여 꽤 쉽게 계산할 수 있습니다.

### 5차 및 고차 곡선: 수치 해 찾기

그리고 여기서 상황이 멈춥니다. 대수학을 사용하여 5차 이상의 다항식에 대한 근을 찾을 수 _없기_ 때문입니다([Abel–Ruffini 정리](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem)로 알려진 사실). 대신 대수학이 단순히 답을 산출할 수 없는 이러한 경우에 대해 [수치 해석](https://en.wikipedia.org/wiki/Numerical_analysis)으로 전환합니다.

그것은 "기호를 조작하여 정확한 답을 찾으려고 하는 대신, 기본 프로세스를 단계의 조합으로 설명하여 근사 답을 찾으며, 각 단계는 기호 조작을 통해 숫자를 _할당할 수 있습니다_"라고 말하는 멋진 용어입니다. 예를 들어 완전히 미친 3차원 형태에 얼마나 많은 물이 들어맞는지 수학적으로 계산하려고 하는 것은 완벽하고 정확한 답을 얻더라도 매우 어렵습니다. 덜 완벽하지만 여전히 완전히 유용한 훨씬 더 쉬운 접근 방식은 양동이를 잡고 가득 찰 때까지 형태를 채우기 시작하는 것입니다. 사용한 물 양동이의 수를 세기만 하면 됩니다. 그리고 더 정확한 답을 원한다면 더 작은 양동이를 사용할 수 있습니다.

그래서 여기서도 그렇게 할 것입니다. 문제를 일련의 단계로 취급할 것이며, 각 단계를 더 작게 만들수록 "완벽하고 정확한" 답에 더 가까워질 것입니다. 그리고 알고 보니 [Newton-Raphson](https://en.wikipedia.org/wiki/Newton-Raphson) 근 찾기 방법(네, *[그](https://en.wikipedia.org/wiki/Isaac_Newton)* Newton 이후)이라는 정말 멋진 수치 근 찾기 알고리즘이 있으며, 이를 사용할 수 있습니다. Newton-Raphson 접근 방식은 불가능하게 풀 수 없는 함수 `f(x)`를 가져와서 초기 값 `x`(문자 그대로 모든 값이 괜찮음)를 선택하고 `f(x)`를 계산하는 것으로 구성됩니다. 그 값을 `x`에서 함수의 "높이"로 생각할 수 있습니다. 그 높이가 0이면 완료되었고 근을 찾은 것입니다. 그렇지 않으면 `f(x)`에서 접선을 계산하고 _그것의_ 높이가 0인 `x` 값을 계산합니다(이미 매우 쉽다는 것을 봤습니다). 그것은 새로운 `x`를 제공하고 근을 찾을 때까지 프로세스를 반복합니다.

수학적으로 이것은 어떤 `x`에 대해 단계 `n=1`에서 다음 `t`가 이미 가지고 있는 것과 같도록 `f<sub>y</sub>(x)`가 0이 될 때까지 다음 계산을 수행한다는 것을 의미합니다.

\[
  x_{n+1} = x_n - \frac{f_y(x_n)}{f'_y(x_n)}
\]

(Wikipedia 기사에는 이 프로세스에 대한 괜찮은 애니메이션이 있으므로 여기에 그래픽을 추가하지 않겠습니다)

이제 이것은 좋은 시작점을 선택할 수 있고 곡선이 [연속 미분 가능](https://en.wikipedia.org/wiki/Continuous_function)하고 [진동](https://en.wikipedia.org/wiki/Oscillation_(mathematics))이 없는 경우에만 잘 작동합니다. 이러한 용어의 정확한 의미를 무시하면 우리가 다루는 곡선은 이러한 제약 조건을 따르므로 좋은 시작점을 선택하는 한 작동합니다. 그렇다면 질문은: 어떤 시작점을 선택할까요?

알고 보니 Newton-Raphson은 너무나 엄청나게 빨라서 선택하지 않아도 괜찮습니다. *t=0*에서 *t=1*까지 작은 단계(예: 1/200)로 알고리즘을 실행하기만 하면 원하는 모든 근이 결과가 됩니다. 물론 이것은 고차 베지에 곡선에 대해 문제를 일으킬 수 있습니다. 200차 베지에 곡선에 대해 200 단계는 잘못될 것이지만, 괜찮습니다. 미친 듯이 높은 차수의 베지에 곡선을 _사용할_ 이유가 없기(적어도 제가 아는 한) 때문입니다. 단일 베지에 곡선으로 완전한 원의 "여전히 원격으로 작동 가능한 가장 좋은" 근사를 얻기 위해 5차 곡선을 사용할 수 있지만, 그것이 필요한 만큼 높은 정도입니다.

### 결론:

이제 근 찾기를 하는 방법을 알았으니, 베지에 곡선에 대한 1차 및 2차 도함수 근을 결정하고 이전 그래픽에 겹쳐진 근을 보여줄 수 있습니다. 2차 곡선의 경우 빨간색으로 1차 도함수만 의미합니다.

<graphics-element title="2차 베지에 곡선 극값" width="825" src="./extremities.js" data-type="quadratic"></graphics-element>

그리고 3차 곡선의 경우 각각 빨간색과 보라색으로 1차 및 2차 도함수를 의미합니다.

<graphics-element title="3차 베지에 곡선 극값" width="825" src="./extremities.js" data-type="cubic"></graphics-element>
