# 곡선 성형하기

"ABC" 관계에 대한 지식, 곡선 위의 점 투영, 그리고 3차 곡선 구성을 위한 합리적으로 보이는 보조 값 추정으로 무장하여, 마침내 곡선 성형을 다룰 수 있습니다. 곡선 위의 점을 끌어서 곡선의 형태를 대화식으로 업데이트하는 것입니다.

2차 곡선의 경우 이것은 정말 간단한 트릭입니다. 커서를 곡선에 투영하면 `t` 값과 초기 `B` 좌표를 얻습니다. 후자는 필요하지도 않습니다. `t` 값과 "커서가 있는 곳 어디든"을 목표 `B`로 하여 관련된 `C`를 계산할 수 있습니다.

\[
  C = u(t)_{q} \cdot \textit{Start} + \left ( 1-u(t)_{q} \right ) \cdot \textit{End}
\]

그런 다음 관련된 `A`:

\[
  A = B - \frac{C - B}{\textit{ratio}(t)_{q}} = B + \frac{B - C}{\textit{ratio}(t)_{q}}
\]

그리고 끝났습니다. 그것이 우리의 새로운 2차 제어점이니까요!

<graphics-element title="2차 베지에 곡선 성형하기" width="825" src="./molding.js" data-type="quadratic"></graphics-element>

이전과 마찬가지로 3차 곡선은 약간 더 많은 작업이 필요합니다. 초기 `t` 값과 ABC 값을 찾는 것은 쉽지만, 그 중요한 `e1`과 `e2` 좌표를 얻는 것은 약간 문제가 될 것입니다... 곡선 생성 섹션에서는 자유롭게 적절한 `t` 값을 직접 선택할 수 있었고, 이를 통해 적절한 `e1`과 `e2` 좌표를 찾을 수 있었습니다. 그것은 좋지만, 곡선을 성형할 때는 그런 사치가 없습니다. 움직이기로 결정한 어떤 점이든 이미 자체 `t` 값과 자체 `e1`과 `e2` 값을 가지고 있으며, 이것들은 곡선의 나머지 부분에는 의미가 없을 수 있습니다.

예를 들어 점을 선택하고 움직이기 시작할 때 "얻은 것을 그대로 사용"하면 어떻게 되는지 봅시다. `t` 값과 `e1`/`e2` 좌표를 보존합니다.

<graphics-element title="3차 베지에 곡선 성형하기" width="825" src="./molding.js" data-type="cubic"></graphics-element>

원래 점 근처에서는 합리적으로 보이지만, 점을 더 멀리 끌수록 "유용한" 것이 줄어듭니다. 특히 점을 기준선을 가로질러 끌면 멋진 곡선으로 바뀌는 대신 그렇지 않습니다.

이를 방지하는 한 가지 방법은 위의 접근 방식과 [곡선 만들기](#pointcurves) 섹션의 접근 방식을 결합하는 것일 수 있습니다. "변경되지 않은 `t`/`e1`/`e2`" 곡선과 "이상적인" 시작/커서/끝 점을 통과하는 이상적인 `t` 값을 가진 곡선을 모두 생성한 다음, 이 두 곡선 사이를 보간합니다.

<graphics-element title="3차 베지에 곡선 성형하기" width="825" src="./molding.js" data-type="cubic" data-interpolated="true">
  <input type="range" min="10" max="200" step="1" value="100" class="slide-control">
</graphics-element>

슬라이드는 곡선의 원래 점이 있는 곳에 상대적인 "감쇠 거리"를 제어하므로, 점을 끌 때 원래 점에 가까울수록 "`t`/`e1`/`e2` 보존"에 편향되고 점을 더 멀리 이동할수록 "이상적인" 형태에 편향되어 보간하며, 감쇠 거리보다 먼 것은 단순히 이상적인 곡선이 _됩니다_. 그 시점에서는 보간을 시도하지도 않습니다.

상황을 부드럽게 하기 위한 더 고급 방법은 _연속_ 성형을 구현하는 것입니다. 이동하면서 곡선을 지속적으로 업데이트하고, _업데이트하는 동안_ 커서를 곡선에 지속적으로 투영하는 것을 기반으로 `B` 점이 무엇인지 지속적으로 변경합니다. 이것은 놀랍지 않게도 까다롭고 이 섹션의 범위를 벗어납니다. 지금은 보간(합리적인 거리로)으로 충분합니다!
