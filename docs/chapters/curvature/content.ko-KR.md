# 곡선의 곡률

두 곡선이 있고, 이것들을 "보기 좋게" 정렬하고 싶다면, 컴퓨터가 "보기 좋음"의 의미를 결정하도록 하는 메트릭으로 무엇을 사용할까요?

예를 들어 두 곡선이 끝 좌표를 공유하도록 하여 한 곡선의 끝과 다음 곡선의 시작 사이에 "간격"이 없도록 하는 것부터 시작할 수 있지만, 이것이 보기 좋음을 보장하지는 않습니다. 두 곡선이 완전히 다른 방향으로 갈 수 있고, 결과 결합된 기하학은 한 곡선에서 다음 곡선으로의 부드러운 전환이 아니라 모서리가 있을 것입니다.

우리가 원하는 것은 한 곡선에서 다음 곡선으로의 전환에서 [곡률](https://en.wikipedia.org/wiki/Curvature)이 "보기 좋게" 보이도록 하는 것입니다. 따라서 공유 좌표부터 시작하고, 해당 좌표에서 두 곡선의 도함수가 일치하도록 요구합니다. 그렇게 하면 접선이 정렬되도록 보장되므로 곡선 전환이 완벽하게 부드러워야 합니다. 더 나은 전환을 위해 2차, 3차 등의 도함수도 일치시킬 수 있습니다.

문제 해결!

그러나 이 접근 방식에는 문제가 있습니다. 이것에 대해 조금 더 생각해보면 "곡선이 어떻게 보이는지"와 그 도함수 값이 거의 완전히 관련이 없다는 것을 깨닫습니다. 결국 [곡선 재정렬](#reordering) 섹션에서 보여준 것처럼 같은 모양의 곡선은 임의로 높은 베지에 차수의 무한한 수의 곡선 표현을 가질 수 있으며, 각각은 _크게_ 다른 도함수 값을 가질 것입니다.

그래서 우리가 정말로 원하는 것은 `t`의 특정 표현에 기반하지 않고, 곡선을 그리는 데 사용하는 함수의 _종류_에 불변인 것에 기반한 일종의 표현입니다. 그리고 이에 대한 주요 후보는 거리에 대해 재매개변수화된 곡선 표현입니다. 어떤 차수의 베지에 곡선을 사용하든, 곡선을 따라 거리의 함수로 다시 쓸 수 있다면, 이러한 모든 다른 차수의 베지에 함수는 "곡선을 따라 일정 거리 D에서의 좌표"에 대해 _같은_ 함수가 될 것입니다.

이전에 본 적이 있습니다... 그것이 호 길이 함수입니다.

따라서 곡선의 곡률을 찾기 위해 이제 호 길이 함수 자체를 풀어야 한다고 생각할 수 있고, 실제로 그렇게 할 방법이 없다는 것을 방금 봤으므로 이것이 상당한 문제가 될 것이라고 생각할 수 있습니다. 다행히도 그렇지 않습니다. 호 길이 함수를 _풀어야_ 하는 것이 아니라 호 길이 함수의 _형태_만 알면 됩니다. 위에서 본 것처럼 꽤 간단합니다. 호 길이 표현으로 시작하여 _그것의_ 도함수를 결정하는 [데 필요한 단계를 실행](https://mathworld.wolfram.com/Curvature.html)하면(이를 수행하는 방법에 대한 대체 짧은 시연은 [Stackexchange에서](https://math.stackexchange.com/questions/275248/deriving-curvature-formula/275324#275324) 찾을 수 있음), 호 길이 함수를 푸는 데 너무 많은 문제를 일으켰던 적분이 완전히 사라지고([미적분학의 기본 정리](https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus) 때문에), 우리에게 남은 것은 곡률(κ, "카파"로 표시)을—그리고 이것이 정말 놀라운 부분입니다—원래 함수의 도함수의 특정 조합과 관련시키는 놀라울 정도로 간단한 수학입니다.

방금 무슨 일이 일어났는지 강조해보겠습니다. 정말 특별하니까요.

1. 곡선을 정렬하고 싶었고, 처음에는 곡선의 도함수를 일치시키려고 생각했지만
2. 그것은 정말 나쁜 선택으로 판명되었으므로 대신
3. 기본적으로 작업하기 불가능한 함수를 선택하고 _그것으로 작업했는데_, 이것이
4. _곡선의 도함수를 사용하는 표현인_ 간단한 공식을 제공합니다.

*미쳤죠!*

하지만 그것이 또한 수학을 강력하게 만드는 것 중 하나입니다. 초기 아이디어가 목표에서 벗어났더라도 생각했던 것보다 훨씬 더 가까울 수 있으며, "우리가 완전히 틀렸다고 생각하는 것"에서 "실제로 놀랍도록 옳은 것에 가까운 것"으로의 여정에서 많은 통찰을 찾을 수 있습니다.

그렇다면 함수는 어떻게 생겼을까요? 이렇습니다.

\[
  \kappa = \frac{{x}'{y}'' - {x}''{y}'}{({x}'^2+{y}'^2)^{\frac{3}{2}}}
\]

이것은 실제로 `t`의 함수를 다루고 있다는 사실을 무시하는 "짧은 형태"일 뿐이므로 조금 확장해봅시다.

\[
  \kappa(t) = \frac{{B_x}'(t){B_y}''(t) - {B_x}''(t){B_y}'(t)}{({B_x}'(t)^2+{B_y}'(t)^2)^{\frac{3}{2}}}
\]

그리고 그것이 조금 더 장황하지만 첫 번째 함수만큼 작업하기 쉽습니다. 어떤(그리고 이것은 과장할 수 없습니다: _어떤_) 곡선 위의 어떤 점에서의 곡률은 1차 및 2차 도함수 외적과 표준 유클리드 거리 함수와 이상하게 유사해 보이는 것 사이의 비율입니다. 그리고 이러한 함수의 어느 것도 계산하기 어렵지 않습니다. 베지에 곡선의 경우 곡선 좌표만 알면 [1차 및 2차 도함수가 무엇인지 알고](#derivatives) 있으므로 어떤 **t** 값에 대해서든 이 함수를 평가하는 것은 기본적인 산술 문제일 뿐입니다.

사실 지금 바로 구현해봅시다.

```
function kappa(t, B):
  d = B.getDerivative(t)
  dd = B.getSecondDerivative(t)
  numerator = d.x * dd.y - dd.x * d.y
  denominator = pow(d.x*d.x + d.y*d.y, 3/2)
  if denominator is 0: return NaN;
  return numerator / denominator
```

쉬웠습니다! (글쎄요, 그 "숫자가 아님" 값은 다운스트림 코드에서 고려해야 하지만, 어쨌든 그것은 프로그래밍의 현실입니다)

이 모든 것을 다루었으니, 곡선을 정렬해봅시다! 다음 그래픽은 똑같아 보이지만 각각 2차 및 3차 함수를 사용하는 두 곡선을 제공합니다. 보시다시피 도함수가 필연적으로 다름에도 불구하고 곡률은(특정 함수 도함수를 "무시"하고 대신 모든 차이를 부드럽게 하는 공식을 제공하는 수학을 기반으로 도출되므로) 정확히 같습니다. 그리고 그 때문에 겹치는 점이 두 곡선에 대해 같은 곡률을 가지도록 함께 놓을 수 있어 가장 부드러운 전환을 제공합니다.

<graphics-element title="2차 및 3차 베지에 곡선에 대한 곡률 일치" width="825" src="./curvature.js"></graphics-element>

이 스케치에서 눈치채셨을 수 있는 한 가지는 때때로 곡률이 괜찮아 보이지만 잘못된 방향을 가리키는 것처럼 보여 곡선을 제대로 정렬하기 어렵다는 것입니다. 물론 이에 대한 해결책은 곡선의 양쪽에 곡률을 표시하는 것이므로 그렇게 해봅시다. 하지만 한 단계 더 나아갑시다. "곡률 반경"도 계산할 수 있는데, 이것은 이 전체 입문서에서 발견할 수 있는 가장 간단한 수학을 사용하여 어떤 점에서든 곡선의 곡률에 "맞는" 암시적 원을 제공합니다.

\[
  R(t) = \frac{1}{\kappa(t)}
\]

그럼 곡률을 곡선의 양쪽에 시각화하고 슬라이더를 사용하여 제어할 수 있는 어떤 점에서 곡선에 "맞는" 원을 보여주는 이전 그래픽을 다시 봅시다.

<graphics-element title="(더 쉬운) 2차 및 3차 베지에 곡선에 대한 곡률 일치" width="825" src="./curvature.js" data-omni="true">
  <input type="range" min="0" max="2" step="0.0005" value="0" class="slide-control">
</graphics-element>
