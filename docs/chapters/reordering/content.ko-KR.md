# 곡선 차수 낮추기와 높이기

베지에 곡선의 흥미로운 속성 중 하나는 *n*차 곡선이 고차 곡선에 특정 제어점을 제공하여 항상 *(n+1)*차 곡선으로 완벽하게 표현될 수 있다는 것입니다.

세 점이 있는 곡선이 있다면 원래 곡선을 정확히 재현하는 네 점이 있는 곡선을 만들 수 있습니다. 먼저 같은 시작점과 끝점을 제공하고, 두 제어점의 경우 "1/3 시작점 + 2/3 제어점"과 "2/3 제어점 + 1/3 끝점"을 선택합니다. 이제 2차 곡선이 아니라 3차 곡선으로 표현된다는 점을 제외하면 이전과 정확히 같은 곡선이 있습니다.

*n*차 곡선을 *(n+1)*차 곡선으로 높이는 일반 규칙은 다음과 같습니다(시작 및 끝 가중치가 이전 곡선의 시작 및 끝 가중치와 같다는 것을 관찰):

\[
  \textit{Bézier}(k,t) = \sum_{i=0}^{k}
                \underset{\textit{이항 항}}{\underbrace{\binom{k}{i}}}
                \cdot\
                \underset{\textit{다항식 항}}{\underbrace{(1-t)^{k-i} \cdot t^{i}}}
                ~\cdot \
                \underset{\textit{새 가중치}}{\underbrace{\left ( \frac{(k-i) \cdot w_i + i \cdot w_{i-1}}{k} \right )}}
  ~,~\textit{with}~k = n+1~\textit{and}~w_{i-1}=0~when~i = 0
\]

그러나 이 규칙은 일반적으로 *n*차 곡선을 *(n-1)*차 곡선으로 안전하게 낮출 수 **없다**는 직접적인 결과도 가지고 있습니다. 제어점을 깔끔하게 "분리"할 수 없기 때문입니다. 시도할 수는 있지만 결과 곡선은 원본과 동일하지 않으며 실제로 완전히 다르게 보일 수 있습니다.

그러나 저차 곡선이 원래 곡선에 "합리적으로 가능한 한 가깝게" 보이도록 하는 놀라울 정도로 좋은 방법이 있습니다. 단일 연산으로 원래 곡선과 저차 곡선 사이의 "최소 제곱 거리"를 최적화할 수 있습니다([Sirver's Castle](https://www.sirver.net/blog/2011/08/23/degree-reduction-of-bezier-curves/)에서도 설명됨). 하지만 사용하려면 약간의 미적분 작업을 한 다음 선형 대수학으로 전환해야 합니다. 행렬 표현 섹션에서 언급했듯이 일부 작업은 미적분 함수보다 행렬로 훨씬 더 쉽게 수행할 수 있으며, 이것이 그러한 작업 중 하나입니다. 그러니까... 가봅시다!

표준 베지에 함수를 가져와서 약간 압축하는 것으로 시작합니다.

\[
  \textit{Bézier}(n,t)
  =
  \sum_{i=0}^{n} w_i B^n_i(t)
  \textit{, where }
  B^n_i(t)
  =
  \binom{n}{i} \cdot (1-t)^{n-i} \cdot t^{i}
\]

그런 다음 어리석은(실제로는 엄청나게 유용한) 미적분 트릭 중 하나를 적용합니다. `t` 값이 항상 0과 1 사이(포함)이므로 `(1-t)` 더하기 `t`가 항상 1로 합산된다는 것을 알고 있습니다. 따라서 모든 값을 `t`와 `1-t`의 합으로 표현할 수 있습니다.

\[
  x = 1 x = \left ( (1-t) + t \right ) x = (1-t) x + t x = x (1-t) + x t
\]

따라서 겉보기에 사소한 관찰로, `(1-t)`와 `t` 성분의 합으로 분할하여 베지에 함수를 다시 씁니다.

\[
  \begin{aligned}
    \textit{Bézier}(n,t) &= (1-t) B(n,t) + t B(n,t) \\
                &= \sum_{i=0}^{n} w_i (1 - t) B^n_i(t) + \sum_{i=0}^{n} w_i t B^n_i(t)
  \end{aligned}
\]

지금까지는 좋습니다. 이제 왜 이렇게 했는지 보기 위해 `(1-t)`와 `t` 부분을 쓰고 무엇을 얻는지 봅시다. 약속하건대 이제 말이 될 것입니다. `(1-t)`로 시작합니다.

\[
  \begin{aligned}
    (1 - t) B^n_i(t) &= (1-t) \frac{n!}{(n-i)!i!}  (1-t)^{n-i} t^i \\
                     &= \frac{n+1-i}{n+1} \frac{(n+1)!}{(n+1-i)!i!} (1-t)^{n+1-i} t^i \\
                     &= \frac{k-i}{k} \frac{k!}{(k-i)!i!} (1-t)^{k-i} t^i, \textit{where } k = n + 1 \\
                     &= \frac{k-i}{k} B^k_i(t)
  \end{aligned}
\]

이 겉보기에 어리석은 트릭을 사용하면 갑자기 n차 베지에 함수의 일부를 (n+1)차 베지에 함수로 표현할 수 있습니다. 그리고 그것은 곡선 차수를 높이는 것처럼 들립니다! 물론 `t` 부분에 대해 그 트릭을 반복할 수 있어야 하지만 그것은 문제가 아닙니다.

\[
  \begin{aligned}
    t B^n_i(t) &= t \frac{n!}{(n-i)!i!} (1-t)^{n-i} t^i \\
               &= \frac{i+1}{n+1} \frac{(n+1)!}{((n+1)-(i+1))!(i+1)!} (1-t)^{(n+1)-(i+1)} t^{i+1} \\
               &= \frac{i+1}{k} \frac{k!}{(k-(i+1))!(i+1)!} (1-t)^{k-(i+1)} t^{i+1}, \textit{where } k = n + 1 \\
               &= \frac{i+1}{k} B^k_{i+1}(t)
  \end{aligned}
\]

따라서 둘 다 `n`차 표현에서 `(n+1)`차 표현으로 변경되었으므로 다시 합칠 수 있습니다. `n`차 함수가 0에서 `n`까지 합산을 했던 곳에서 `n+1`차 함수는 0에서 `n+1`까지 합산을 사용하지만, "아무것도 기여하지 않는" 새로운 항을 추가할 수 있는 한 문제가 되지 않습니다. 도함수에 대한 다음 섹션에서는 "이항식이 있는 것보다 높은 항"과 "0보다 낮은 항"이 모두 "아무것도 기여하지 않는" 이유에 대한 논의가 있습니다. 따라서 필요한 항과 같은 형태를 가진 항을 추가할 수 있는 한, 합산에 포함시키기만 하면 되고, 거기 앉아서 아무것도 하지 않으며, 결과 함수는 저차 곡선과 동일하게 유지됩니다.

이렇게 해봅시다.

\[
  \begin{aligned}
    Bézier(n,t) &= \sum_{i=0}^{n+1} w_i (1 - t) B^n_i(t) + \sum_{i=0}^{n+1} w_i t B^n_i(t) \\
                &= \sum_{i=0}^{n+1} w_i \frac{k-i}{k} B^k_i(t) + \sum_{i=0}^{n+1} w_i \frac{i+1}{k} B^k_{i+1}(t), \textit{where } k = n + 1 \\
                &= \sum_{i=0}^{n+1} w_i \frac{k-i}{k} B^k_i(t) + \sum_{i=0}^{n+1} p_{i-1} \frac{i}{k} B^k_i(t) \\
                &= \sum_{i=0}^{n+1} \left ( w_i \frac{k-i}{k} + p_{i-1} \frac{i}{k} \right ) B^k_i(t) \\
                &= \sum_{i=0}^{n+1} \left ( w_i (1-s) + p_{i-1} s \right ) B^k_i(t), \textit{where } s = \frac{i}{k}
  \end{aligned}
\]

그리고 여기서 미적분에서 선형 대수학과 행렬로 전환합니다. 이제 Bézier(n,t)와 Bézier(n+1,t) 사이의 관계를 매우 간단한 행렬 곱셈으로 표현할 수 있습니다.

\[
  M B_n = B_k
\]

여기서 행렬 **M**은 `n+1` by `n` 행렬이며 다음과 같습니다.

\[
M =
\left [
\begin{matrix}
     1      &        0      &        .      &        .      &  .  &       .       &         .       & . \\
\frac{1}{k} & \frac{k-1}{k} &        0      &        .      &  .  &       .       &         0       & . \\
     0      & \frac{2}{k}   & \frac{k-2}{k} &        0      &  .  &       .       &         .       & . \\
     .      &        0      & \frac{3}{k}   & \frac{k-3}{k} &  0  &       .       &         .       & . \\
     .      &        .      &        0      &       ...     & ... &       0       &         .       & . \\
     .      &        .      &        .      &        0      & ... &      ...      &         0       & . \\
     .      &        .      &        .      &        .      &  0  & \frac{n-1}{k} & \frac{k-n+1}{k} & 0 \\
     .      &        0      &        .      &        .      &  .  &       0       & \frac{n}{k}     & \frac{k-n}{k} \\
     .      &        .      &        .      &        .      &  .  &       .       &         0       & 1
\end{matrix}
\right ]
\]

다루기 어려워 보일 수 있지만 실제로는 대부분 0인 행렬이며, 대각선에 매우 간단한 분수가 있고 왼쪽에 훨씬 더 간단한 분수가 있습니다. 좌표 목록에 이 행렬을 곱하면 결과 변환된 좌표를 1차 높은 함수에 대입하여 똑같이 보이는 곡선을 얻을 수 있습니다.

나쁘지 않습니다!

그러나 똑같이 흥미로운 것은 이 행렬 연산이 확립되면 이제 [정규 방정식](https://mathworld.wolfram.com/NormalEquation.html)이라는 연산을 역전하는 "최적 맞춤" 방법을 찾기 위해 믿을 수 없을 정도로 강력하고 우스꽝스러울 정도로 간단한 방법을 사용할 수 있다는 것입니다. 한 값 집합과 다른 값 집합 사이의 제곱 차이의 합을 최소화합니다. 구체적으로, 어떤 함수 **A x = b**로 표현할 수 있으면 사용할 수 있습니다. 그리고 우연히도 그것이 정확히 우리가 다루고 있는 것이므로:

\[
\begin{aligned}
  M B_n &= B_k \\
  (M^T M) B_n &= M^T B_k\\
  (M^T M)^{-1} (M^T M) B_n &= (M^T M)^{-1} M^T B_k \\
  I B_n &= (M^T M)^{-1} M^T B_k \\
  B_n &= (M^T M)^{-1} M^T B_k
\end{aligned}
\]

여기서 취한 단계는 다음과 같습니다.

1. 정규 방정식을 사용할 수 있는 형태의 함수가 있으므로
2. 정규 방정식을 적용합니다!
3. 그런 다음 왼쪽에 B<sub>n</sub>만 남기를 원하므로 양변을 왼쪽 곱셈하여 왼쪽에 "인수 1"로 단순화되는 많은 것들로 끝나도록 하는 것으로 시작하며, 행렬 수학에서는 [단위 행렬](https://en.wikipedia.org/wiki/Identity_matrix)입니다.
4. 사실 이미 있던 것의 역행렬로 왼쪽 곱셈함으로써, 그 크고 다루기 어려운 블록을 단위 행렬 **I**로 효과적으로 "무효화"(하지만 실제로는 일원화)했습니다. 따라서 복잡한 것을 **I**로 대체한 다음
5. 단위 행렬과의 곱셈은 아무것도 하지 않기 때문에(일반 대수학에서 1을 곱하는 것이 아무것도 하지 않는 것처럼), 그냥 버립니다.

그리고 끝났습니다. 이제 `n+1`차 곡선을 저차 `n`차 곡선으로 근사할 수 있는 표현이 생겼습니다. 정확한 맞춤은 아니지만 확실히 최선의 근사입니다. 그럼 다음 그래픽을 사용하여 (반) 무작위 곡선에 대해 곡선 차수를 높이고 낮추는 이러한 규칙을 구현해봅시다. 이동 가능한 제어점이 있는 스케치를 선택하고 상하 방향키를 눌러 곡선 차수를 높이거나 낮추세요.

<graphics-element title="가변 차수 베지에 곡선" src="./reorder.js">
  <button class="raise">높이기</button>
  <button class="lower">낮추기</button>
</graphics-element>
