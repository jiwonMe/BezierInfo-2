# 베지에 곡률 제어하기, 파트 2: 유리 베지에

베지에 곡선을 "유리화"하여 추가로 제어할 수 있습니다. 즉, 이전 섹션에서 논의한 가중치 값에 "비율" 값을 추가하여 각 좌표가 곡선에 "얼마나 강하게" 영향을 미치는지 제어할 수 있습니다.

이러한 비율 값을 일반 베지에 곡선 함수에 추가하는 것은 상당히 쉽습니다. 일반 함수가 다음과 같을 때:

\[
  \textit{Bézier}(n,t) = \sum_{i=0}^{n} \binom{n}{i} \cdot (1-t)^{n-i} \cdot t^{i} \cdot w_i
\]

유리 베지에 곡선에 대한 함수에는 두 가지 항이 더 있습니다.

\[
  \textit{Rational Bézier}(n,t) = \frac{ \sum_{i=0}^{n} \binom{n}{i} \cdot (1-t)^{n-i} \cdot t^{i} \cdot w_i \cdot BLUE[ratio_i] }{ BLUE[ \sum_{i=0}^{n} \binom{n}{i} \cdot (1-t)^{n-i} \cdot t^{i} \cdot ratio_i ] }
\]

이 중 첫 번째 새 항은 각 좌표에 대한 추가 가중치를 나타냅니다. 예를 들어 비율 값이 [1, 0.5, 0.5, 1]이면 <code>ratio<sub>0</sub> = 1</code>, <code>ratio<sub>1</sub> = 0.5</code> 등이며, 다른 가중치를 사용하는 것과 효과적으로 동일합니다. 지금까지는 특별한 것이 없습니다.

그러나 두 번째 새 항이 차이를 만듭니다. 곡선의 모든 점은 단순히 "이중 가중" 점이 아니라 비율을 도입하여 계산하는 "이중 가중" 값의 _분수_입니다. 곡선의 점을 계산할 때 "일반" 베지에 값을 계산한 다음 가중치가 아닌 비율만 사용하는 곡선의 베지에 값으로 _나눕니다_.

이것은 예상치 못한 일을 합니다. 다항식을 더 이상 다항식이 _아닌_ 것으로 바꿉니다. 이제 다항식의 상위 클래스인 일종의 곡선이 되며, 표준 베지에 곡선이 "자체적으로" 할 수 없는 정말 멋진 작업을 수행할 수 있습니다. 예를 들어 원을 완벽하게 설명하는 것(나중 섹션에서 표준 베지에 곡선을 사용하면 문자 그대로 불가능하다는 것을 보게 됩니다)입니다.

하지만 이것이 무엇을 하는지 보여주는 가장 좋은 방법은 문자 그대로 그렇게 하는 것입니다. 유리화된 곡선에 대한 인터랙티브 그래픽을 사용하여 베지에 곡선을 "유리화"하는 효과를 살펴봅시다. 다음 그래픽은 이전 섹션의 베지에 곡선을 각 좌표에 대한 비율 인수로 "강화"한 것을 보여줍니다. 하나 이상의 항을 0에 가깝게 설정할수록 관련 좌표가 곡선에 미치는 상대적 영향이 줄어들고(물론 더 높게 설정할수록 더 많은 영향을 미칩니다), 값을 변경하고 그려지는 것에 어떤 영향을 미치는지 확인해보세요.

<graphics-element title="유리 3차 베지에 곡선" src="./rational.js">
  <input type="range" min="0.01" max="2" value="1" step="0.01" class="ratio-1">
  <input type="range" min="0.01" max="2" value="1" step="0.01" class="ratio-2">
  <input type="range" min="0.01" max="2" value="1" step="0.01" class="ratio-3">
  <input type="range" min="0.01" max="2" value="1" step="0.01" class="ratio-4">
</graphics-element>

비율 값을 각 좌표의 "중력"으로 생각할 수 있습니다. 중력이 높을수록 곡선이 그 좌표에 더 가까이 가려고 합니다. 또한 모든 비율을 같은 양만큼 늘리거나 줄이면 아무것도 변하지 않는다는 것을 알 수 있습니다... 중력과 마찬가지로 상대적 강도가 같으면 실제로 아무것도 변하지 않습니다. 값은 각 좌표의 영향을 _다른 모든 점에 대해 상대적으로_ 정의합니다.

<div class="howtocode">

### 유리 곡선 구현 방법

이전 섹션의 코드를 확장하여 비율을 포함하는 것은 거의 사소합니다.

```
function RationalBezier(2,t,w[],r[]):
  t2 = t * t
  mt = 1-t
  mt2 = mt * mt
  f = [
    r[0] * mt2,
    2 * r[1] * mt * t,
    r[2] * t2
  ]
  basis = f[0] + f[1] + f[2]
  return (f[0] * w[0] + f[1] * w[1] + f[2] * w[2])/basis

function RationalBezier(3,t,w[],r[]):
  t2 = t * t
  t3 = t2 * t
  mt = 1-t
  mt2 = mt * mt
  mt3 = mt2 * mt
  f = [
    r[0] * mt3,
    3 * r[1] * mt2 * t,
    3 * r[2] * mt * t2,
    r[3] * t3
  ]
  basis = f[0] + f[1] + f[2] + f[3]
  return (f[0] * w[0] + f[1] * w[1] + f[2] * w[2] + f[3] * w[3])/basis
```

그리고 그것이 우리가 해야 할 전부입니다.

</div>
